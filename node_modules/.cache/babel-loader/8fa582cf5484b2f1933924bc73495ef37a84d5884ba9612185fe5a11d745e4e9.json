{"ast":null,"code":"export class ScoringEngine {\n  constructor(customScoring) {\n    this.customScoring = customScoring;\n    this.defaultWeights = {\n      technology: 0.3,\n      process: 0.3,\n      people: 0.2,\n      strategy: 0.2\n    };\n    this.weights = (customScoring === null || customScoring === void 0 ? void 0 : customScoring.weights) || this.defaultWeights;\n  }\n  calculate(responses, context) {\n    console.log('Starting score calculation with responses:', Object.keys(responses).length);\n    console.log('Context for calculation:', context);\n    try {\n      var _this$customScoring;\n      // Base scoring logic used by all assessments\n      let scores = this.calculateDimensionScores(responses);\n\n      // Apply custom scoring if provided\n      if ((_this$customScoring = this.customScoring) !== null && _this$customScoring !== void 0 && _this$customScoring.calculate) {\n        try {\n          const customScores = this.customScoring.calculate(scores, responses, context);\n          if (customScores) scores = customScores;\n        } catch (error) {\n          console.error('Error in custom scoring calculation:', error);\n        }\n      }\n\n      // Apply context-based adjustments\n      scores = this.applyContextAdjustments(scores, context);\n\n      // Calculate overall score\n      const overall = this.calculateOverallScore(scores);\n\n      // Generate insights\n      const result = {\n        scores: {\n          overall: overall,\n          categories: scores\n        },\n        insights: this.generateInsights({\n          overall,\n          dimensions: scores\n        }, context),\n        report: this.generateReport({\n          overall,\n          dimensions: scores\n        }, context)\n      };\n      console.log('Final calculation result:', result);\n      return result;\n    } catch (error) {\n      console.error('Error in score calculation:', error);\n\n      // Return a fallback result to prevent UI errors\n      return {\n        scores: {\n          overall: 50,\n          categories: {\n            technology: {\n              score: 50\n            },\n            process: {\n              score: 50\n            },\n            people: {\n              score: 50\n            },\n            strategy: {\n              score: 50\n            }\n          }\n        },\n        insights: [{\n          type: 'warning',\n          title: 'Score Calculation Issue',\n          description: 'There was an issue calculating your detailed scores.'\n        }],\n        report: this.generateDefaultReport()\n      };\n    }\n  }\n  calculateDimensionScores(responses) {\n    // Default implementation for base dimension calculation\n    console.log('Calculating dimension scores with responses:', responses);\n\n    // Extract question responses and organize them by category\n    const categories = {};\n\n    // Initialize default categories with zero scores\n    const defaultCategories = ['technology', 'process', 'people', 'strategy'];\n    defaultCategories.forEach(cat => {\n      categories[cat] = {\n        score: 0,\n        count: 0,\n        responses: []\n      };\n    });\n\n    // Process each response\n    Object.entries(responses).forEach(([questionId, answer]) => {\n      // Skip non-numeric responses or special properties\n      if (typeof answer !== 'number' || questionId === 'selectedServices') return;\n\n      // Determine category from question ID - default to 'technology' if unknown\n      // Format might be: tech_01, people_02, etc.\n      const category = questionId.split('_')[0] || 'technology';\n      const normalizedCategory = this.normalizeCategory(category);\n\n      // If category not initialized, create it\n      if (!categories[normalizedCategory]) {\n        categories[normalizedCategory] = {\n          score: 0,\n          count: 0,\n          responses: []\n        };\n      }\n\n      // Add the score (assuming questions are scored 0-5)\n      categories[normalizedCategory].score += answer;\n      categories[normalizedCategory].count++;\n      categories[normalizedCategory].responses.push({\n        id: questionId,\n        value: answer\n      });\n    });\n\n    // Calculate average scores for each category\n    const dimensionScores = {};\n    Object.entries(categories).forEach(([category, data]) => {\n      dimensionScores[category] = {\n        score: data.count > 0 ? Math.round(data.score / (data.count * 5) * 100) : 0,\n        responses: data.responses\n      };\n    });\n    console.log('Calculated dimension scores:', dimensionScores);\n    return dimensionScores;\n  }\n  calculateOverallScore(dimensionScores) {\n    // Default implementation for overall score calculation\n    console.log('Calculating overall score with dimension scores:', dimensionScores);\n    let weightedSum = 0;\n    let totalWeight = 0;\n\n    // Calculate weighted sum of dimension scores\n    Object.entries(dimensionScores).forEach(([dimension, data]) => {\n      const weight = this.weights[dimension] || 0.25; // Default equal weight if not specified\n      weightedSum += (data.score || 0) * weight;\n      totalWeight += weight;\n    });\n\n    // Calculate overall score (rounded to nearest integer)\n    const overallScore = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 50;\n    console.log('Calculated overall score:', overallScore);\n    return overallScore;\n  }\n  applyContextAdjustments(scores, context) {\n    // Apply size, industry, or other contextual adjustments\n    console.log('Applying context adjustments with context:', context);\n\n    // If no context, return scores unchanged\n    if (!context) return scores;\n\n    // Example: Adjust for company size\n    if (context.companySize) {\n      // Small companies might get a boost in technology score\n      if (context.companySize === 'small' && scores.technology) {\n        scores.technology.score = Math.min(100, scores.technology.score + 5);\n      }\n    }\n\n    // Example: Adjust for selected services\n    if (context.selectedServices) {\n      const serviceCount = Object.keys(context.selectedServices).length;\n      // More focused companies (fewer services) might score higher in strategy\n      if (serviceCount <= 2 && scores.strategy) {\n        scores.strategy.score = Math.min(100, scores.strategy.score + 5);\n      }\n    }\n    return scores;\n  }\n  generateInsights(scores, context) {\n    // Generate insights based on scores\n    const insights = [];\n\n    // Only proceed if we have valid scores\n    if (!scores) return insights;\n\n    // Generate overall insights\n    if (typeof scores.overall === 'number') {\n      if (scores.overall < 30) {\n        insights.push({\n          type: 'critical',\n          title: 'Significant Improvement Needed',\n          description: 'Your marketing maturity score indicates substantial room for improvement across multiple dimensions.'\n        });\n      } else if (scores.overall < 60) {\n        insights.push({\n          type: 'warning',\n          title: 'Building Foundations',\n          description: 'You have some marketing fundamentals in place, but there are key areas that need strengthening.'\n        });\n      } else if (scores.overall < 80) {\n        insights.push({\n          type: 'positive',\n          title: 'Solid Performance',\n          description: 'Your marketing operations show good maturity with specific opportunities for optimization.'\n        });\n      } else {\n        insights.push({\n          type: 'excellent',\n          title: 'Marketing Excellence',\n          description: 'Your marketing organization demonstrates high levels of maturity and effectiveness.'\n        });\n      }\n    }\n\n    // Generate dimension-specific insights\n    Object.entries(scores.dimensions || {}).forEach(([dimension, data]) => {\n      if (typeof data.score === 'number' && data.score < 50) {\n        insights.push({\n          type: 'opportunity',\n          dimension: dimension,\n          title: `${this.formatDimension(dimension)} Opportunity`,\n          description: `Your ${this.formatDimension(dimension)} score suggests this is a high-priority area for improvement.`\n        });\n      }\n    });\n    return insights;\n  }\n}\nexport default ScoringEngine;","map":{"version":3,"names":["ScoringEngine","constructor","customScoring","defaultWeights","technology","process","people","strategy","weights","calculate","responses","context","console","log","Object","keys","length","_this$customScoring","scores","calculateDimensionScores","customScores","error","applyContextAdjustments","overall","calculateOverallScore","result","categories","insights","generateInsights","dimensions","report","generateReport","score","type","title","description","generateDefaultReport","defaultCategories","forEach","cat","count","entries","questionId","answer","category","split","normalizedCategory","normalizeCategory","push","id","value","dimensionScores","data","Math","round","weightedSum","totalWeight","dimension","weight","overallScore","companySize","min","selectedServices","serviceCount","formatDimension"],"sources":["/Users/jon/Documents/GitHub/assessor/src/core/engine/ScoringEngine.js"],"sourcesContent":["export class ScoringEngine {\n    constructor(customScoring) {\n        this.customScoring = customScoring;\n        this.defaultWeights = {\n            technology: 0.3,\n            process: 0.3,\n            people: 0.2,\n            strategy: 0.2\n        };\n        this.weights = customScoring?.weights || this.defaultWeights;\n    }\n\n    calculate(responses, context) {\n        console.log('Starting score calculation with responses:', Object.keys(responses).length);\n        console.log('Context for calculation:', context);\n        \n        try {\n            // Base scoring logic used by all assessments\n            let scores = this.calculateDimensionScores(responses);\n    \n            // Apply custom scoring if provided\n            if (this.customScoring?.calculate) {\n                try {\n                    const customScores = this.customScoring.calculate(scores, responses, context);\n                    if (customScores) scores = customScores;\n                } catch (error) {\n                    console.error('Error in custom scoring calculation:', error);\n                }\n            }\n    \n            // Apply context-based adjustments\n            scores = this.applyContextAdjustments(scores, context);\n    \n            // Calculate overall score\n            const overall = this.calculateOverallScore(scores);\n            \n            // Generate insights\n            const result = {\n                scores: {\n                    overall: overall,\n                    categories: scores\n                },\n                insights: this.generateInsights({ overall, dimensions: scores }, context),\n                report: this.generateReport({ overall, dimensions: scores }, context)\n            };\n            \n            console.log('Final calculation result:', result);\n            return result;\n        } catch (error) {\n            console.error('Error in score calculation:', error);\n            \n            // Return a fallback result to prevent UI errors\n            return {\n                scores: {\n                    overall: 50,\n                    categories: {\n                        technology: { score: 50 },\n                        process: { score: 50 },\n                        people: { score: 50 },\n                        strategy: { score: 50 }\n                    }\n                },\n                insights: [{\n                    type: 'warning',\n                    title: 'Score Calculation Issue',\n                    description: 'There was an issue calculating your detailed scores.'\n                }],\n                report: this.generateDefaultReport()\n            };\n        }\n    }\n\n    calculateDimensionScores(responses) {\n        // Default implementation for base dimension calculation\n        console.log('Calculating dimension scores with responses:', responses);\n        \n        // Extract question responses and organize them by category\n        const categories = {};\n        \n        // Initialize default categories with zero scores\n        const defaultCategories = ['technology', 'process', 'people', 'strategy'];\n        defaultCategories.forEach(cat => {\n            categories[cat] = { score: 0, count: 0, responses: [] };\n        });\n        \n        // Process each response\n        Object.entries(responses).forEach(([questionId, answer]) => {\n            // Skip non-numeric responses or special properties\n            if (typeof answer !== 'number' || questionId === 'selectedServices') return;\n            \n            // Determine category from question ID - default to 'technology' if unknown\n            // Format might be: tech_01, people_02, etc.\n            const category = questionId.split('_')[0] || 'technology';\n            const normalizedCategory = this.normalizeCategory(category);\n            \n            // If category not initialized, create it\n            if (!categories[normalizedCategory]) {\n                categories[normalizedCategory] = { score: 0, count: 0, responses: [] };\n            }\n            \n            // Add the score (assuming questions are scored 0-5)\n            categories[normalizedCategory].score += answer;\n            categories[normalizedCategory].count++;\n            categories[normalizedCategory].responses.push({ id: questionId, value: answer });\n        });\n        \n        // Calculate average scores for each category\n        const dimensionScores = {};\n        Object.entries(categories).forEach(([category, data]) => {\n            dimensionScores[category] = {\n                score: data.count > 0 ? Math.round((data.score / (data.count * 5)) * 100) : 0,\n                responses: data.responses\n            };\n        });\n        \n        console.log('Calculated dimension scores:', dimensionScores);\n        return dimensionScores;\n    }\n\n    calculateOverallScore(dimensionScores) {\n        // Default implementation for overall score calculation\n        console.log('Calculating overall score with dimension scores:', dimensionScores);\n        \n        let weightedSum = 0;\n        let totalWeight = 0;\n        \n        // Calculate weighted sum of dimension scores\n        Object.entries(dimensionScores).forEach(([dimension, data]) => {\n            const weight = this.weights[dimension] || 0.25; // Default equal weight if not specified\n            weightedSum += (data.score || 0) * weight;\n            totalWeight += weight;\n        });\n        \n        // Calculate overall score (rounded to nearest integer)\n        const overallScore = totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 50;\n        \n        console.log('Calculated overall score:', overallScore);\n        return overallScore;\n    }\n\n    applyContextAdjustments(scores, context) {\n        // Apply size, industry, or other contextual adjustments\n        console.log('Applying context adjustments with context:', context);\n        \n        // If no context, return scores unchanged\n        if (!context) return scores;\n        \n        // Example: Adjust for company size\n        if (context.companySize) {\n            // Small companies might get a boost in technology score\n            if (context.companySize === 'small' && scores.technology) {\n                scores.technology.score = Math.min(100, scores.technology.score + 5);\n            }\n        }\n        \n        // Example: Adjust for selected services\n        if (context.selectedServices) {\n            const serviceCount = Object.keys(context.selectedServices).length;\n            // More focused companies (fewer services) might score higher in strategy\n            if (serviceCount <= 2 && scores.strategy) {\n                scores.strategy.score = Math.min(100, scores.strategy.score + 5);\n            }\n        }\n        \n        return scores;\n    }\n\n    generateInsights(scores, context) {\n        // Generate insights based on scores\n        const insights = [];\n        \n        // Only proceed if we have valid scores\n        if (!scores) return insights;\n        \n        // Generate overall insights\n        if (typeof scores.overall === 'number') {\n            if (scores.overall < 30) {\n                insights.push({\n                    type: 'critical',\n                    title: 'Significant Improvement Needed',\n                    description: 'Your marketing maturity score indicates substantial room for improvement across multiple dimensions.'\n                });\n            } else if (scores.overall < 60) {\n                insights.push({\n                    type: 'warning',\n                    title: 'Building Foundations',\n                    description: 'You have some marketing fundamentals in place, but there are key areas that need strengthening.'\n                });\n            } else if (scores.overall < 80) {\n                insights.push({\n                    type: 'positive',\n                    title: 'Solid Performance',\n                    description: 'Your marketing operations show good maturity with specific opportunities for optimization.'\n                });\n            } else {\n                insights.push({\n                    type: 'excellent',\n                    title: 'Marketing Excellence',\n                    description: 'Your marketing organization demonstrates high levels of maturity and effectiveness.'\n                });\n            }\n        }\n        \n        // Generate dimension-specific insights\n        Object.entries(scores.dimensions || {}).forEach(([dimension, data]) => {\n            if (typeof data.score === 'number' && data.score < 50) {\n                insights.push({\n                    type: 'opportunity',\n                    dimension: dimension,\n                    title: `${this.formatDimension(dimension)} Opportunity`,\n                    description: `Your ${this.formatDimension(dimension)} score suggests this is a high-priority area for improvement.`\n                });\n            }\n        });\n        \n        return insights;\n    }\n}\n\nexport default ScoringEngine;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}