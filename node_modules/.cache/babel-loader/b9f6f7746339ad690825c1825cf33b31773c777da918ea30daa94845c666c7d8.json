{"ast":null,"code":"export class ScoringEngine {\n  constructor(customScoring, assessmentType = 'agency-vulnerability') {\n    this.customScoring = customScoring;\n    this.assessmentType = assessmentType;\n    this.weights = (customScoring === null || customScoring === void 0 ? void 0 : customScoring.weights) || this.defaultWeights;\n    this.specificScoringEngine = null;\n\n    // Initialize the specific scoring engine\n    this.initializeSpecificEngine();\n  }\n\n  /**\n   * Dynamically load and instantiate the assessment-specific scoring engine\n   */\n  async initializeSpecificEngine() {\n    try {\n      // Dynamically import the appropriate scoring engine based on assessment type\n      const scoringModule = await import(`../../assessments/${this.assessmentType}/scoring.js`);\n      const ScoringClass = scoringModule.default;\n      if (ScoringClass) {\n        this.specificScoringEngine = new ScoringClass(this.customScoring);\n        console.log(`Loaded specific scoring engine for ${this.assessmentType}`);\n      } else {\n        console.warn(`Scoring module found for ${this.assessmentType} but no default export`);\n      }\n    } catch (error) {\n      console.error(`Failed to load scoring engine for ${this.assessmentType}:`, error);\n      // Continue with base implementation if specific engine can't be loaded\n    }\n  }\n  async calculate(responses, context) {\n    var _this$customScoring;\n    // Ensure specific scoring engine is initialized\n    if (!this.specificScoringEngine) {\n      await this.initializeSpecificEngine();\n    }\n\n    // If we have a specific scoring engine, use it\n    if (this.specificScoringEngine && this.specificScoringEngine.calculateScores) {\n      try {\n        var _specificScores$score;\n        // Use the assessment-specific calculation method\n        const specificScores = this.specificScoringEngine.calculateScores(responses, context);\n\n        // Format the result to match our expected structure\n        // Handle different return formats from different scoring engines\n\n        // For overall score - check different possible property names\n        const overall = specificScores.overallScore || specificScores.overall || ((_specificScores$score = specificScores.scores) === null || _specificScores$score === void 0 ? void 0 : _specificScores$score.overall) || 0;\n\n        // For dimensions - could be dimensions property or direct properties in specificScores\n        let dimensions;\n        if (specificScores.dimensions) {\n          dimensions = specificScores.dimensions;\n        } else if (specificScores.dimensionScores) {\n          dimensions = specificScores.dimensionScores;\n        } else {\n          // Create dimensions from known properties for different scoring engines\n          dimensions = {};\n\n          // For agency scoring\n          if (specificScores.transformationScore !== undefined) {\n            dimensions.transformation = specificScores.transformationScore;\n            dimensions.valuation = specificScores.valuationScore;\n          }\n\n          // For inhouse marketing scoring\n          if (specificScores.humanReadiness !== undefined) {\n            dimensions.humanReadiness = specificScores.humanReadiness;\n            dimensions.technicalReadiness = specificScores.technicalReadiness;\n            dimensions.activityAutomation = specificScores.activityAutomation;\n          }\n        }\n\n        // Get insights if available or generate them\n        const insights = specificScores.insights || this.generateInsights(specificScores, context);\n\n        // Additional data passed through intact\n        const additionalData = {};\n\n        // Copy relevant data from the specific scoring engine's result\n        if (specificScores.categoryScores) additionalData.categoryScores = specificScores.categoryScores;\n        if (specificScores.activityScores) additionalData.activityScores = specificScores.activityScores;\n        if (specificScores.serviceScores) additionalData.serviceScores = specificScores.serviceScores;\n        if (specificScores.valuationMetrics) additionalData.valuationMetrics = specificScores.valuationMetrics;\n        if (specificScores.vulnerabilityMetrics) additionalData.vulnerabilityMetrics = specificScores.vulnerabilityMetrics;\n        return {\n          overall: overall,\n          dimensions: dimensions,\n          insights: insights,\n          ...additionalData\n        };\n      } catch (error) {\n        console.error('Error using specific scoring engine:', error);\n        // Fall back to base implementation\n      }\n    }\n\n    // Base scoring logic used by all assessments (fallback)\n    console.log('Using base scoring implementation');\n    let scores = this.calculateDimensionScores(responses);\n\n    // Apply custom scoring if provided\n    if ((_this$customScoring = this.customScoring) !== null && _this$customScoring !== void 0 && _this$customScoring.calculate) {\n      scores = this.customScoring.calculate(scores, responses, context);\n    }\n\n    // Apply context-based adjustments\n    scores = this.applyContextAdjustments(scores, context);\n    return {\n      overall: this.calculateOverallScore(scores),\n      dimensions: scores,\n      insights: this.generateInsights(scores, context)\n    };\n  }\n  calculateDimensionScores(responses) {\n    // Implementation for base dimension calculation\n    return {};\n  }\n  calculateOverallScore(dimensionScores) {\n    // Implementation for overall score calculation\n    return 0;\n  }\n  applyContextAdjustments(scores, context) {\n    // Apply size, industry, or other contextual adjustments\n    return scores;\n  }\n  generateInsights(scores, context) {\n    // Generate insights based on scores\n    return [];\n  }\n\n  /**\n   * Generate a complete assessment report with detailed insights and recommendations\n   * Delegates to assessment-specific report generation if available\n   */\n  async generateReport(scores, context) {\n    // Ensure specific scoring engine is initialized\n    if (!this.specificScoringEngine) {\n      await this.initializeSpecificEngine();\n    }\n\n    // If specific scoring engine has report generation capabilities, use them\n    if (this.specificScoringEngine) {\n      // Check for various report generation methods that might exist in specific engines\n      if (typeof this.specificScoringEngine.generateReport === 'function') {\n        return this.specificScoringEngine.generateReport(scores, context);\n      }\n\n      // Check for other report methods that might exist\n      if (typeof this.specificScoringEngine.identifyTransformationPriorities === 'function') {\n        var _this$specificScoring, _this$specificScoring2;\n        // For agency scoring\n        const priorities = this.specificScoringEngine.identifyTransformationPriorities(scores.dimensions, context.selectedServices ? this.specificScoringEngine.calculateServiceScores(scores, context.selectedServices) : {}, ((_this$specificScoring = (_this$specificScoring2 = this.specificScoringEngine).calculateDetailedRiskFactors) === null || _this$specificScoring === void 0 ? void 0 : _this$specificScoring.call(_this$specificScoring2, scores, context)) || {}, context.agencySize || context.companySize);\n\n        // Build a report structure with the priorities\n        return this.generateBaseReport(scores, context, priorities);\n      } else if (typeof this.specificScoringEngine.identifyPriorities === 'function') {\n        // For inhouse marketing scoring\n        const priorities = this.specificScoringEngine.identifyPriorities(scores.categoryScores || {}, scores.activityScores || {}, context.selectedActivities || [], context.companySize || context.teamSize);\n\n        // Build a report structure with the priorities\n        return this.generateBaseReport(scores, context, priorities);\n      }\n    }\n\n    // Fallback to basic report generation\n    return this.generateBaseReport(scores, context);\n  }\n\n  /**\n   * Generate a basic report structure as fallback\n   */\n  generateBaseReport(scores, context, priorities = []) {\n    const title = this.assessmentType === 'inhouse-marketing' ? 'Marketing AI Maturity Assessment' : 'Agency AI Vulnerability Assessment';\n    return {\n      title: title,\n      summary: this.generateSummary(scores),\n      executive: {\n        headline: 'Your Assessment Results',\n        subheadline: 'Detailed analysis and recommendations below',\n        overallScore: scores.overall || 0\n      },\n      readiness: {\n        title: `${this.assessmentType === 'inhouse-marketing' ? 'Marketing' : 'Agency'} AI Readiness Assessment`,\n        subtitle: 'How your organization compares across key dimensions',\n        dimensions: this.generateDimensionCards(scores)\n      },\n      recommendations: priorities || [],\n      nextSteps: {\n        booking: {\n          headline: 'Ready to move forward?',\n          subheadline: 'Schedule a consultation to get personalized insights'\n        }\n      }\n    };\n  }\n\n  /**\n   * Generate a summary based on the overall score\n   */\n  generateSummary(scores) {\n    const overallScore = scores.overall || scores.overallScore || 0;\n    if (overallScore < 30) {\n      return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} is in the early stages of AI readiness. There are significant opportunities to improve.`;\n    } else if (overallScore < 60) {\n      return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} has established some AI foundations but needs further development in key areas.`;\n    } else if (overallScore < 80) {\n      return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} demonstrates good AI maturity with specific opportunities for optimization.`;\n    } else {\n      return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} shows high AI maturity across multiple dimensions. Focus on refinement and innovation.`;\n    }\n  }\n\n  /**\n   * Generate dimension cards for the readiness section\n   */\n  generateDimensionCards(scores) {\n    const dimensionCards = [];\n    const dimensionData = scores.dimensions || {};\n\n    // Generate card for each dimension\n    Object.entries(dimensionData).forEach(([dimension, data]) => {\n      const score = typeof data === 'object' ? data.score || 0 : data || 0;\n      dimensionCards.push({\n        name: this.formatDimension(dimension),\n        score: score,\n        description: `Your ${this.formatDimension(dimension).toLowerCase()} score indicates ${score < 40 ? 'areas for improvement' : score < 70 ? 'moderate capability' : 'strong capability'}.`\n      });\n    });\n\n    // Sort by score (descending)\n    dimensionCards.sort((a, b) => b.score - a.score);\n    return dimensionCards;\n  }\n\n  /**\n   * Format dimension names for display\n   */\n  formatDimension(dimension) {\n    // Format dimension names for display\n    const dimensionLabels = {\n      'technology': 'Technology',\n      'process': 'Process',\n      'people': 'People',\n      'strategy': 'Strategy',\n      'content': 'Content',\n      'analytics': 'Analytics',\n      'humanReadiness': 'Human Readiness',\n      'technicalReadiness': 'Technical Readiness',\n      'activityAutomation': 'Activity Automation',\n      'transformation': 'Transformation',\n      'resources': 'Resources',\n      'leadership': 'Leadership',\n      'change': 'Change Readiness'\n    };\n    return dimensionLabels[dimension] || dimension.charAt(0).toUpperCase() + dimension.slice(1).replace(/([A-Z])/g, ' $1');\n  }\n}\nexport default ScoringEngine;","map":{"version":3,"names":["ScoringEngine","constructor","customScoring","assessmentType","weights","defaultWeights","specificScoringEngine","initializeSpecificEngine","scoringModule","ScoringClass","default","console","log","warn","error","calculate","responses","context","_this$customScoring","calculateScores","_specificScores$score","specificScores","overall","overallScore","scores","dimensions","dimensionScores","transformationScore","undefined","transformation","valuation","valuationScore","humanReadiness","technicalReadiness","activityAutomation","insights","generateInsights","additionalData","categoryScores","activityScores","serviceScores","valuationMetrics","vulnerabilityMetrics","calculateDimensionScores","applyContextAdjustments","calculateOverallScore","generateReport","identifyTransformationPriorities","_this$specificScoring","_this$specificScoring2","priorities","selectedServices","calculateServiceScores","calculateDetailedRiskFactors","call","agencySize","companySize","generateBaseReport","identifyPriorities","selectedActivities","teamSize","title","summary","generateSummary","executive","headline","subheadline","readiness","subtitle","generateDimensionCards","recommendations","nextSteps","booking","dimensionCards","dimensionData","Object","entries","forEach","dimension","data","score","push","name","formatDimension","description","toLowerCase","sort","a","b","dimensionLabels","charAt","toUpperCase","slice","replace"],"sources":["/Users/jon/Documents/GitHub/assessor/src/core/engine/ScoringEngine.js"],"sourcesContent":["export class ScoringEngine {\n    constructor(customScoring, assessmentType = 'agency-vulnerability') {\n        this.customScoring = customScoring;\n        this.assessmentType = assessmentType;\n        this.weights = customScoring?.weights || this.defaultWeights;\n        this.specificScoringEngine = null;\n        \n        // Initialize the specific scoring engine\n        this.initializeSpecificEngine();\n    }\n    \n    /**\n     * Dynamically load and instantiate the assessment-specific scoring engine\n     */\n    async initializeSpecificEngine() {\n        try {\n            // Dynamically import the appropriate scoring engine based on assessment type\n            const scoringModule = await import(`../../assessments/${this.assessmentType}/scoring.js`);\n            const ScoringClass = scoringModule.default;\n            \n            if (ScoringClass) {\n                this.specificScoringEngine = new ScoringClass(this.customScoring);\n                console.log(`Loaded specific scoring engine for ${this.assessmentType}`);\n            } else {\n                console.warn(`Scoring module found for ${this.assessmentType} but no default export`);\n            }\n        } catch (error) {\n            console.error(`Failed to load scoring engine for ${this.assessmentType}:`, error);\n            // Continue with base implementation if specific engine can't be loaded\n        }\n    }\n\n    async calculate(responses, context) {\n        // Ensure specific scoring engine is initialized\n        if (!this.specificScoringEngine) {\n            await this.initializeSpecificEngine();\n        }\n        \n        // If we have a specific scoring engine, use it\n        if (this.specificScoringEngine && this.specificScoringEngine.calculateScores) {\n            try {\n                // Use the assessment-specific calculation method\n                const specificScores = this.specificScoringEngine.calculateScores(responses, context);\n                \n                // Format the result to match our expected structure\n                // Handle different return formats from different scoring engines\n                \n                // For overall score - check different possible property names\n                const overall = specificScores.overallScore || specificScores.overall || \n                               (specificScores.scores?.overall) || 0;\n                \n                // For dimensions - could be dimensions property or direct properties in specificScores\n                let dimensions;\n                if (specificScores.dimensions) {\n                    dimensions = specificScores.dimensions;\n                } else if (specificScores.dimensionScores) {\n                    dimensions = specificScores.dimensionScores;\n                } else {\n                    // Create dimensions from known properties for different scoring engines\n                    dimensions = {};\n                    \n                    // For agency scoring\n                    if (specificScores.transformationScore !== undefined) {\n                        dimensions.transformation = specificScores.transformationScore;\n                        dimensions.valuation = specificScores.valuationScore;\n                    }\n                    \n                    // For inhouse marketing scoring\n                    if (specificScores.humanReadiness !== undefined) {\n                        dimensions.humanReadiness = specificScores.humanReadiness;\n                        dimensions.technicalReadiness = specificScores.technicalReadiness;\n                        dimensions.activityAutomation = specificScores.activityAutomation;\n                    }\n                }\n                \n                // Get insights if available or generate them\n                const insights = specificScores.insights || this.generateInsights(specificScores, context);\n                \n                // Additional data passed through intact\n                const additionalData = {};\n                \n                // Copy relevant data from the specific scoring engine's result\n                if (specificScores.categoryScores) additionalData.categoryScores = specificScores.categoryScores;\n                if (specificScores.activityScores) additionalData.activityScores = specificScores.activityScores;\n                if (specificScores.serviceScores) additionalData.serviceScores = specificScores.serviceScores;\n                if (specificScores.valuationMetrics) additionalData.valuationMetrics = specificScores.valuationMetrics;\n                if (specificScores.vulnerabilityMetrics) additionalData.vulnerabilityMetrics = specificScores.vulnerabilityMetrics;\n                \n                return {\n                    overall: overall,\n                    dimensions: dimensions,\n                    insights: insights,\n                    ...additionalData\n                };\n            } catch (error) {\n                console.error('Error using specific scoring engine:', error);\n                // Fall back to base implementation\n            }\n        }\n        \n        // Base scoring logic used by all assessments (fallback)\n        console.log('Using base scoring implementation');\n        let scores = this.calculateDimensionScores(responses);\n\n        // Apply custom scoring if provided\n        if (this.customScoring?.calculate) {\n            scores = this.customScoring.calculate(scores, responses, context);\n        }\n\n        // Apply context-based adjustments\n        scores = this.applyContextAdjustments(scores, context);\n\n        return {\n            overall: this.calculateOverallScore(scores),\n            dimensions: scores,\n            insights: this.generateInsights(scores, context)\n        };\n    }\n\n    calculateDimensionScores(responses) {\n        // Implementation for base dimension calculation\n        return {};\n    }\n\n    calculateOverallScore(dimensionScores) {\n        // Implementation for overall score calculation\n        return 0;\n    }\n\n    applyContextAdjustments(scores, context) {\n        // Apply size, industry, or other contextual adjustments\n        return scores;\n    }\n\n    generateInsights(scores, context) {\n        // Generate insights based on scores\n        return [];\n    }\n    \n    /**\n     * Generate a complete assessment report with detailed insights and recommendations\n     * Delegates to assessment-specific report generation if available\n     */\n    async generateReport(scores, context) {\n        // Ensure specific scoring engine is initialized\n        if (!this.specificScoringEngine) {\n            await this.initializeSpecificEngine();\n        }\n        \n        // If specific scoring engine has report generation capabilities, use them\n        if (this.specificScoringEngine) {\n            // Check for various report generation methods that might exist in specific engines\n            if (typeof this.specificScoringEngine.generateReport === 'function') {\n                return this.specificScoringEngine.generateReport(scores, context);\n            }\n            \n            // Check for other report methods that might exist\n            if (typeof this.specificScoringEngine.identifyTransformationPriorities === 'function') {\n                // For agency scoring\n                const priorities = this.specificScoringEngine.identifyTransformationPriorities(\n                    scores.dimensions, \n                    context.selectedServices ? this.specificScoringEngine.calculateServiceScores(scores, context.selectedServices) : {},\n                    this.specificScoringEngine.calculateDetailedRiskFactors?.(scores, context) || {},\n                    context.agencySize || context.companySize\n                );\n                \n                // Build a report structure with the priorities\n                return this.generateBaseReport(scores, context, priorities);\n            } else if (typeof this.specificScoringEngine.identifyPriorities === 'function') {\n                // For inhouse marketing scoring\n                const priorities = this.specificScoringEngine.identifyPriorities(\n                    scores.categoryScores || {},\n                    scores.activityScores || {},\n                    context.selectedActivities || [],\n                    context.companySize || context.teamSize\n                );\n                \n                // Build a report structure with the priorities\n                return this.generateBaseReport(scores, context, priorities);\n            }\n        }\n        \n        // Fallback to basic report generation\n        return this.generateBaseReport(scores, context);\n    }\n    \n    /**\n     * Generate a basic report structure as fallback\n     */\n    generateBaseReport(scores, context, priorities = []) {\n        const title = this.assessmentType === 'inhouse-marketing' ? \n            'Marketing AI Maturity Assessment' : \n            'Agency AI Vulnerability Assessment';\n            \n        return {\n            title: title,\n            summary: this.generateSummary(scores),\n            executive: {\n                headline: 'Your Assessment Results',\n                subheadline: 'Detailed analysis and recommendations below',\n                overallScore: scores.overall || 0\n            },\n            readiness: {\n                title: `${this.assessmentType === 'inhouse-marketing' ? 'Marketing' : 'Agency'} AI Readiness Assessment`,\n                subtitle: 'How your organization compares across key dimensions',\n                dimensions: this.generateDimensionCards(scores)\n            },\n            recommendations: priorities || [],\n            nextSteps: {\n                booking: {\n                    headline: 'Ready to move forward?',\n                    subheadline: 'Schedule a consultation to get personalized insights'\n                }\n            }\n        };\n    }\n    \n    /**\n     * Generate a summary based on the overall score\n     */\n    generateSummary(scores) {\n        const overallScore = scores.overall || scores.overallScore || 0;\n        \n        if (overallScore < 30) {\n            return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} is in the early stages of AI readiness. There are significant opportunities to improve.`;\n        } else if (overallScore < 60) {\n            return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} has established some AI foundations but needs further development in key areas.`;\n        } else if (overallScore < 80) {\n            return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} demonstrates good AI maturity with specific opportunities for optimization.`;\n        } else {\n            return `Your ${this.assessmentType === 'inhouse-marketing' ? 'marketing team' : 'agency'} shows high AI maturity across multiple dimensions. Focus on refinement and innovation.`;\n        }\n    }\n    \n    /**\n     * Generate dimension cards for the readiness section\n     */\n    generateDimensionCards(scores) {\n        const dimensionCards = [];\n        const dimensionData = scores.dimensions || {};\n        \n        // Generate card for each dimension\n        Object.entries(dimensionData).forEach(([dimension, data]) => {\n            const score = typeof data === 'object' ? (data.score || 0) : (data || 0);\n            \n            dimensionCards.push({\n                name: this.formatDimension(dimension),\n                score: score,\n                description: `Your ${this.formatDimension(dimension).toLowerCase()} score indicates ${score < 40 ? 'areas for improvement' : score < 70 ? 'moderate capability' : 'strong capability'}.`\n            });\n        });\n        \n        // Sort by score (descending)\n        dimensionCards.sort((a, b) => b.score - a.score);\n        \n        return dimensionCards;\n    }\n    \n    /**\n     * Format dimension names for display\n     */\n    formatDimension(dimension) {\n        // Format dimension names for display\n        const dimensionLabels = {\n            'technology': 'Technology',\n            'process': 'Process',\n            'people': 'People',\n            'strategy': 'Strategy',\n            'content': 'Content',\n            'analytics': 'Analytics',\n            'humanReadiness': 'Human Readiness',\n            'technicalReadiness': 'Technical Readiness',\n            'activityAutomation': 'Activity Automation',\n            'transformation': 'Transformation',\n            'resources': 'Resources',\n            'leadership': 'Leadership',\n            'change': 'Change Readiness'\n        };\n        \n        return dimensionLabels[dimension] || \n               (dimension.charAt(0).toUpperCase() + dimension.slice(1).replace(/([A-Z])/g, ' $1'));\n    }\n}\n\nexport default ScoringEngine;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}