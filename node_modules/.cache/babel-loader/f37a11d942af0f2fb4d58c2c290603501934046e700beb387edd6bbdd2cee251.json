{"ast":null,"code":"var _jsxFileName = \"/Users/jon/Documents/GitHub/assessor/src/core/components/DynamicQuestions.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { ProgressBar } from './ProgressBar';\nimport Navigation from './Navigation';\nimport styles from '../styles/components.module.css';\n\n// Debug helper function\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst debugLog = (message, data) => {\n  console.log(`DEBUG - ${message}:`, data);\n};\nconst DynamicQuestions = ({\n  assessmentType,\n  saveResponse,\n  getResponse,\n  getContext,\n  setContext,\n  onComplete,\n  onBack,\n  progress\n}) => {\n  _s();\n  const [questions, setQuestions] = useState([]);\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    loadQuestions();\n  }, [assessmentType]);\n  const loadQuestions = async () => {\n    try {\n      setLoading(true);\n      debugLog('Loading questions for assessment type', assessmentType);\n\n      // Load core questions based on assessment type\n      const module = await import(`../../assessments/${assessmentType}/questions.json`);\n      const data = module.default || module;\n\n      // Extract and flatten core questions array from the loaded data\n      let coreQuestions = [];\n      if (data.questions) {\n        // Direct questions array format\n        coreQuestions = data.questions;\n      } else if (data.coreQuestions) {\n        // Nested questions by category format\n        Object.values(data.coreQuestions).forEach(questionSet => {\n          if (Array.isArray(questionSet)) {\n            coreQuestions = [...coreQuestions, ...questionSet];\n          }\n        });\n      }\n      debugLog(`Loaded core questions`, coreQuestions.length);\n\n      // If we have selected services, load service-specific questions\n      let serviceQuestions = [];\n\n      // Get selected services from context or responses with detailed logging\n      let selectedServices;\n      debugLog('Trying to get selectedServices', '');\n      try {\n        // First try context if available\n        if (typeof getContext === 'function') {\n          debugLog('getContext function is available', '');\n          selectedServices = getContext('selectedServices');\n          debugLog('selectedServices from context', selectedServices);\n        } else {\n          debugLog('getContext is not a function', '');\n        }\n\n        // If not found in context, fall back to response\n        if (!selectedServices && typeof getResponse === 'function') {\n          debugLog('Trying getResponse for selectedServices', '');\n          selectedServices = getResponse('selectedServices');\n          debugLog('selectedServices from responses', selectedServices);\n        }\n\n        // Log the selected services format\n        if (selectedServices) {\n          debugLog('selectedServices type', typeof selectedServices);\n          debugLog('selectedServices keys', Object.keys(selectedServices));\n          debugLog('selectedServices values', Object.values(selectedServices));\n        } else {\n          debugLog('selectedServices is null or undefined', '');\n        }\n      } catch (err) {\n        console.error('Error getting selectedServices:', err);\n      }\n      if (selectedServices && Object.keys(selectedServices).length > 0) {\n        try {\n          // Load service-specific questions\n          debugLog(`Loading service questions from path`, `../../assessments/${assessmentType}/service-questions.json`);\n          const serviceModule = await import(`../../assessments/${assessmentType}/service-questions.json`);\n          const serviceData = serviceModule.default || serviceModule;\n\n          // Check if the service data has the proper structure\n          if (serviceData) {\n            debugLog('Service questions data structure', Object.keys(serviceData));\n\n            // Threshold to determine if a service allocation is high enough to include questions\n            // Lower threshold to 5% (0.05) to be more inclusive\n            const ALLOCATION_THRESHOLD = 0.05;\n\n            // Add service questions based on selected services\n            Object.keys(selectedServices).forEach(serviceId => {\n              const allocation = selectedServices[serviceId];\n              if (allocation >= ALLOCATION_THRESHOLD) {\n                debugLog(`Service ${serviceId} allocation ${allocation} exceeds threshold ${ALLOCATION_THRESHOLD}`, '');\n\n                // Different approaches to match service questions based on data structure\n                // 1. Try matching by serviceId directly\n                if (serviceData[serviceId]) {\n                  debugLog(`Found questions for service ID ${serviceId}`, serviceData[serviceId].length || 0);\n                  serviceQuestions = [...serviceQuestions, ...(serviceData[serviceId] || [])];\n                }\n                // 2. Try matching by \"service_id\" property\n                else if (serviceData.questions) {\n                  const matchingQuestions = serviceData.questions.filter(q => q.service_id === serviceId || q.serviceId === serviceId);\n                  debugLog(`Found ${matchingQuestions.length} questions with service_id ${serviceId}`, '');\n                  serviceQuestions = [...serviceQuestions, ...matchingQuestions];\n                }\n                // 3. Try finding questions with service ID in tags or category\n                else {\n                  // Try to find a way to match questions to services\n                  let matchedAny = false;\n\n                  // Check if service questions are grouped by categories\n                  Object.keys(serviceData).forEach(key => {\n                    // Check if the key contains or matches the service ID\n                    if (key.toLowerCase().includes(serviceId.toLowerCase()) || serviceId.toLowerCase().includes(key.toLowerCase())) {\n                      const questions = serviceData[key];\n                      if (Array.isArray(questions)) {\n                        debugLog(`Found ${questions.length} questions for service key ${key} matching ${serviceId}`, '');\n                        serviceQuestions = [...serviceQuestions, ...questions];\n                        matchedAny = true;\n                      }\n                    }\n                  });\n                  if (!matchedAny) {\n                    debugLog(`Could not find questions for service ${serviceId} in data structure`, Object.keys(serviceData));\n                  }\n                }\n              } else {\n                debugLog(`Service ${serviceId} allocation ${allocation} below threshold ${ALLOCATION_THRESHOLD}`, '');\n              }\n            });\n          } else {\n            debugLog('Service data is empty or invalid', serviceData);\n          }\n        } catch (error) {\n          console.error('Error loading service questions:', error);\n        }\n      } else {\n        console.warn('No services selected or invalid selectedServices format:', selectedServices);\n      }\n      debugLog(`Found service-specific questions`, serviceQuestions.length);\n\n      // Remove any potential duplicate questions by ID\n      const uniqueQuestions = [];\n      const questionIds = new Set();\n\n      // First add core questions\n      coreQuestions.forEach(q => {\n        if (!questionIds.has(q.id)) {\n          questionIds.add(q.id);\n          uniqueQuestions.push(q);\n        }\n      });\n\n      // Then add service questions, avoiding duplicates\n      serviceQuestions.forEach(q => {\n        if (!questionIds.has(q.id)) {\n          questionIds.add(q.id);\n          uniqueQuestions.push(q);\n        }\n      });\n      debugLog(`Total unique questions to display`, uniqueQuestions.length);\n      debugLog('Question IDs', Array.from(questionIds));\n      setQuestions(uniqueQuestions);\n    } catch (error) {\n      console.error('Failed to load questions:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  const currentQuestion = questions[currentQuestionIndex];\n  const isLastQuestion = currentQuestionIndex === questions.length - 1;\n  const handleAnswer = (questionId, value) => {\n    // Save the answer\n    saveResponse(questionId, value);\n\n    // Auto-advance to next question after a short delay\n    setTimeout(() => {\n      if (currentQuestionIndex < questions.length - 1) {\n        setCurrentQuestionIndex(currentQuestionIndex + 1);\n      }\n    }, 300);\n  };\n  const handleNext = () => {\n    // Validate if the current question is answered\n    const currentQ = questions[currentQuestionIndex];\n    if (currentQ && currentQ.required !== false && !getResponse(currentQ.id)) {\n      alert('Please answer this question before continuing');\n      return;\n    }\n    if (isLastQuestion) {\n      // Before completing, ensure selectedServices is stored in both context and responses\n      if (typeof getContext === 'function') {\n        const selectedServices = getContext('selectedServices');\n        if (selectedServices && typeof saveResponse === 'function') {\n          // Save as a response to ensure it's available in both places\n          saveResponse('selectedServices', selectedServices);\n          debugLog('Saved selectedServices to responses as backup', selectedServices);\n        }\n      }\n\n      // Move to the next stage using onComplete callback\n      if (onComplete) {\n        onComplete();\n      }\n    } else {\n      setCurrentQuestionIndex(prev => prev + 1);\n    }\n  };\n  const handlePrevious = () => {\n    if (currentQuestionIndex > 0) {\n      setCurrentQuestionIndex(prev => prev - 1);\n    } else {\n      // Go back to the previous stage in the assessment flow\n      onBack();\n    }\n  };\n  const handleSkip = () => {\n    handleNext();\n  };\n  if (loading) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.loadingContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.spinner\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 257,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading questions...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 258,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 256,\n      columnNumber: 13\n    }, this);\n  }\n  if (!currentQuestion) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.errorContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"No questions available for this assessment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 266,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: onBack,\n        children: \"Go Back\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 265,\n      columnNumber: 13\n    }, this);\n  }\n  const selectedValue = getResponse(currentQuestion.id);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: styles.qualifyingContainer,\n    children: [/*#__PURE__*/_jsxDEV(ProgressBar, {\n      progress: progress || 65,\n      stage: \"assessment\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 276,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.questionContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.questionHeader,\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"Your Organization Assessment\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 280,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: styles.questionNumber,\n          children: [\"Question \", currentQuestionIndex + 1, \" of \", questions.length]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 281,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 279,\n        columnNumber: 17\n      }, this), currentQuestion && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.questionContent,\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          className: styles.questionText,\n          children: [currentQuestion.question || currentQuestion.text, currentQuestion.required !== false && /*#__PURE__*/_jsxDEV(\"span\", {\n            className: styles.required,\n            children: \"*\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 290,\n            columnNumber: 68\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 288,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.optionsGrid,\n          children: currentQuestion.options.map((option, index) => /*#__PURE__*/_jsxDEV(\"button\", {\n            className: `${styles.optionButton} ${selectedValue === (option.value || option.score || index) ? styles.selected : ''}`,\n            onClick: () => handleAnswer(currentQuestion.id, option.value || option.score || index),\n            children: /*#__PURE__*/_jsxDEV(\"span\", {\n              className: styles.optionLabel,\n              children: option.label || option.text\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 302,\n              columnNumber: 37\n            }, this)\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 295,\n            columnNumber: 33\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 293,\n          columnNumber: 25\n        }, this), currentQuestion.insight && /*#__PURE__*/_jsxDEV(\"p\", {\n          className: styles.questionInsight,\n          children: currentQuestion.insight\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 308,\n          columnNumber: 29\n        }, this), currentQuestion.benchmark && /*#__PURE__*/_jsxDEV(\"p\", {\n          className: styles.questionBenchmark,\n          children: currentQuestion.benchmark\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 312,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 287,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.questionDots,\n        children: questions.map((_, index) => /*#__PURE__*/_jsxDEV(\"button\", {\n          className: `${styles.dot} ${index === currentQuestionIndex ? styles.active : ''} ${getResponse(questions[index].id) ? styles.answered : ''}`,\n          onClick: () => setCurrentQuestionIndex(index),\n          \"aria-label\": `Go to question ${index + 1}`\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 320,\n          columnNumber: 25\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 318,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 278,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Navigation, {\n      onBack: handlePrevious,\n      onNext: handleNext,\n      onSkip: (currentQuestion === null || currentQuestion === void 0 ? void 0 : currentQuestion.required) === false ? handleSkip : null,\n      nextLabel: isLastQuestion ? \"Complete\" : \"Continue\",\n      showNext: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 332,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 275,\n    columnNumber: 9\n  }, this);\n};\n_s(DynamicQuestions, \"hJiJQOXcC+XQPaBxuPtmnYbXKjw=\");\n_c = DynamicQuestions;\nexport default DynamicQuestions;\nvar _c;\n$RefreshReg$(_c, \"DynamicQuestions\");","map":{"version":3,"names":["React","useState","useEffect","ProgressBar","Navigation","styles","jsxDEV","_jsxDEV","debugLog","message","data","console","log","DynamicQuestions","assessmentType","saveResponse","getResponse","getContext","setContext","onComplete","onBack","progress","_s","questions","setQuestions","currentQuestionIndex","setCurrentQuestionIndex","loading","setLoading","loadQuestions","module","default","coreQuestions","Object","values","forEach","questionSet","Array","isArray","length","serviceQuestions","selectedServices","keys","err","error","serviceModule","serviceData","ALLOCATION_THRESHOLD","serviceId","allocation","matchingQuestions","filter","q","service_id","matchedAny","key","toLowerCase","includes","warn","uniqueQuestions","questionIds","Set","has","id","add","push","from","currentQuestion","isLastQuestion","handleAnswer","questionId","value","setTimeout","handleNext","currentQ","required","alert","prev","handlePrevious","handleSkip","className","loadingContainer","children","spinner","fileName","_jsxFileName","lineNumber","columnNumber","errorContainer","onClick","selectedValue","qualifyingContainer","stage","questionContainer","questionHeader","questionNumber","questionContent","questionText","question","text","optionsGrid","options","map","option","index","optionButton","score","selected","optionLabel","label","insight","questionInsight","benchmark","questionBenchmark","questionDots","_","dot","active","answered","onNext","onSkip","nextLabel","showNext","_c","$RefreshReg$"],"sources":["/Users/jon/Documents/GitHub/assessor/src/core/components/DynamicQuestions.jsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { ProgressBar } from './ProgressBar';\nimport Navigation from './Navigation';\nimport styles from '../styles/components.module.css';\n\n// Debug helper function\nconst debugLog = (message, data) => {\n    console.log(`DEBUG - ${message}:`, data);\n};\n\nconst DynamicQuestions = ({ \n    assessmentType, \n    saveResponse, \n    getResponse, \n    getContext,\n    setContext, \n    onComplete,\n    onBack,\n    progress\n}) => {\n    const [questions, setQuestions] = useState([]);\n    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        loadQuestions();\n    }, [assessmentType]);\n\n    const loadQuestions = async () => {\n        try {\n            setLoading(true);\n            debugLog('Loading questions for assessment type', assessmentType);\n            \n            // Load core questions based on assessment type\n            const module = await import(`../../assessments/${assessmentType}/questions.json`);\n            const data = module.default || module;\n            \n            // Extract and flatten core questions array from the loaded data\n            let coreQuestions = [];\n            if (data.questions) {\n                // Direct questions array format\n                coreQuestions = data.questions;\n            } else if (data.coreQuestions) {\n                // Nested questions by category format\n                Object.values(data.coreQuestions).forEach(questionSet => {\n                    if (Array.isArray(questionSet)) {\n                        coreQuestions = [...coreQuestions, ...questionSet];\n                    }\n                });\n            }\n            debugLog(`Loaded core questions`, coreQuestions.length);\n            \n            // If we have selected services, load service-specific questions\n            let serviceQuestions = [];\n            \n            // Get selected services from context or responses with detailed logging\n            let selectedServices;\n            debugLog('Trying to get selectedServices', '');\n            \n            try {\n                // First try context if available\n                if (typeof getContext === 'function') {\n                    debugLog('getContext function is available', '');\n                    selectedServices = getContext('selectedServices');\n                    debugLog('selectedServices from context', selectedServices);\n                } else {\n                    debugLog('getContext is not a function', '');\n                }\n                \n                // If not found in context, fall back to response\n                if (!selectedServices && typeof getResponse === 'function') {\n                    debugLog('Trying getResponse for selectedServices', '');\n                    selectedServices = getResponse('selectedServices');\n                    debugLog('selectedServices from responses', selectedServices);\n                }\n                \n                // Log the selected services format\n                if (selectedServices) {\n                    debugLog('selectedServices type', typeof selectedServices);\n                    debugLog('selectedServices keys', Object.keys(selectedServices));\n                    debugLog('selectedServices values', Object.values(selectedServices));\n                } else {\n                    debugLog('selectedServices is null or undefined', '');\n                }\n            } catch (err) {\n                console.error('Error getting selectedServices:', err);\n            }\n            \n            if (selectedServices && Object.keys(selectedServices).length > 0) {\n                try {\n                    // Load service-specific questions\n                    debugLog(`Loading service questions from path`, `../../assessments/${assessmentType}/service-questions.json`);\n                    \n                    const serviceModule = await import(`../../assessments/${assessmentType}/service-questions.json`);\n                    const serviceData = serviceModule.default || serviceModule;\n                    \n                    // Check if the service data has the proper structure\n                    if (serviceData) {\n                        debugLog('Service questions data structure', Object.keys(serviceData));\n                        \n                        // Threshold to determine if a service allocation is high enough to include questions\n                        // Lower threshold to 5% (0.05) to be more inclusive\n                        const ALLOCATION_THRESHOLD = 0.05;\n                        \n                        // Add service questions based on selected services\n                        Object.keys(selectedServices).forEach(serviceId => {\n                            const allocation = selectedServices[serviceId];\n                            \n                            if (allocation >= ALLOCATION_THRESHOLD) {\n                                debugLog(`Service ${serviceId} allocation ${allocation} exceeds threshold ${ALLOCATION_THRESHOLD}`, '');\n                                \n                                // Different approaches to match service questions based on data structure\n                                // 1. Try matching by serviceId directly\n                                if (serviceData[serviceId]) {\n                                    debugLog(`Found questions for service ID ${serviceId}`, serviceData[serviceId].length || 0);\n                                    serviceQuestions = [...serviceQuestions, ...(serviceData[serviceId] || [])];\n                                }\n                                // 2. Try matching by \"service_id\" property\n                                else if (serviceData.questions) {\n                                    const matchingQuestions = serviceData.questions.filter(q => \n                                        q.service_id === serviceId || q.serviceId === serviceId\n                                    );\n                                    debugLog(`Found ${matchingQuestions.length} questions with service_id ${serviceId}`, '');\n                                    serviceQuestions = [...serviceQuestions, ...matchingQuestions];\n                                }\n                                // 3. Try finding questions with service ID in tags or category\n                                else {\n                                    // Try to find a way to match questions to services\n                                    let matchedAny = false;\n                                    \n                                    // Check if service questions are grouped by categories\n                                    Object.keys(serviceData).forEach(key => {\n                                        // Check if the key contains or matches the service ID\n                                        if (\n                                            key.toLowerCase().includes(serviceId.toLowerCase()) || \n                                            serviceId.toLowerCase().includes(key.toLowerCase())\n                                        ) {\n                                            const questions = serviceData[key];\n                                            if (Array.isArray(questions)) {\n                                                debugLog(`Found ${questions.length} questions for service key ${key} matching ${serviceId}`, '');\n                                                serviceQuestions = [...serviceQuestions, ...questions];\n                                                matchedAny = true;\n                                            }\n                                        }\n                                    });\n                                    \n                                    if (!matchedAny) {\n                                        debugLog(`Could not find questions for service ${serviceId} in data structure`, Object.keys(serviceData));\n                                    }\n                                }\n                            } else {\n                                debugLog(`Service ${serviceId} allocation ${allocation} below threshold ${ALLOCATION_THRESHOLD}`, '');\n                            }\n                        });\n                    } else {\n                        debugLog('Service data is empty or invalid', serviceData);\n                    }\n                } catch (error) {\n                    console.error('Error loading service questions:', error);\n                }\n            } else {\n                console.warn('No services selected or invalid selectedServices format:', selectedServices);\n            }\n            \n            debugLog(`Found service-specific questions`, serviceQuestions.length);\n            \n            // Remove any potential duplicate questions by ID\n            const uniqueQuestions = [];\n            const questionIds = new Set();\n            \n            // First add core questions\n            coreQuestions.forEach(q => {\n                if (!questionIds.has(q.id)) {\n                    questionIds.add(q.id);\n                    uniqueQuestions.push(q);\n                }\n            });\n            \n            // Then add service questions, avoiding duplicates\n            serviceQuestions.forEach(q => {\n                if (!questionIds.has(q.id)) {\n                    questionIds.add(q.id);\n                    uniqueQuestions.push(q);\n                }\n            });\n            \n            debugLog(`Total unique questions to display`, uniqueQuestions.length);\n            debugLog('Question IDs', Array.from(questionIds));\n            \n            setQuestions(uniqueQuestions);\n        } catch (error) {\n            console.error('Failed to load questions:', error);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const currentQuestion = questions[currentQuestionIndex];\n    const isLastQuestion = currentQuestionIndex === questions.length - 1;\n\n    const handleAnswer = (questionId, value) => {\n        // Save the answer\n        saveResponse(questionId, value);\n        \n        // Auto-advance to next question after a short delay\n        setTimeout(() => {\n            if (currentQuestionIndex < questions.length - 1) {\n                setCurrentQuestionIndex(currentQuestionIndex + 1);\n            }\n        }, 300);\n    };\n\n    const handleNext = () => {\n        // Validate if the current question is answered\n        const currentQ = questions[currentQuestionIndex];\n        if (currentQ && currentQ.required !== false && !getResponse(currentQ.id)) {\n            alert('Please answer this question before continuing');\n            return;\n        }\n        \n        if (isLastQuestion) {\n            // Before completing, ensure selectedServices is stored in both context and responses\n            if (typeof getContext === 'function') {\n                const selectedServices = getContext('selectedServices');\n                if (selectedServices && typeof saveResponse === 'function') {\n                    // Save as a response to ensure it's available in both places\n                    saveResponse('selectedServices', selectedServices);\n                    debugLog('Saved selectedServices to responses as backup', selectedServices);\n                }\n            }\n            \n            // Move to the next stage using onComplete callback\n            if (onComplete) {\n                onComplete();\n            }\n        } else {\n            setCurrentQuestionIndex(prev => prev + 1);\n        }\n    };\n\n    const handlePrevious = () => {\n        if (currentQuestionIndex > 0) {\n            setCurrentQuestionIndex(prev => prev - 1);\n        } else {\n            // Go back to the previous stage in the assessment flow\n            onBack();\n        }\n    };\n\n    const handleSkip = () => {\n        handleNext();\n    };\n\n    if (loading) {\n        return (\n            <div className={styles.loadingContainer}>\n                <div className={styles.spinner} />\n                <p>Loading questions...</p>\n            </div>\n        );\n    }\n\n    if (!currentQuestion) {\n        return (\n            <div className={styles.errorContainer}>\n                <p>No questions available for this assessment.</p>\n                <button onClick={onBack}>Go Back</button>\n            </div>\n        );\n    }\n\n    const selectedValue = getResponse(currentQuestion.id);\n\n    return (\n        <div className={styles.qualifyingContainer}>\n            <ProgressBar progress={progress || 65} stage=\"assessment\" />\n            \n            <div className={styles.questionContainer}>\n                <div className={styles.questionHeader}>\n                    <h2>Your Organization Assessment</h2>\n                    <p className={styles.questionNumber}>\n                        Question {currentQuestionIndex + 1} of {questions.length}\n                    </p>\n                </div>\n\n                {currentQuestion && (\n                    <div className={styles.questionContent}>\n                        <h3 className={styles.questionText}>\n                            {currentQuestion.question || currentQuestion.text}\n                            {currentQuestion.required !== false && <span className={styles.required}>*</span>}\n                        </h3>\n                        \n                        <div className={styles.optionsGrid}>\n                            {currentQuestion.options.map((option, index) => (\n                                <button\n                                    key={index}\n                                    className={`${styles.optionButton} ${\n                                        selectedValue === (option.value || option.score || index) ? styles.selected : ''\n                                    }`}\n                                    onClick={() => handleAnswer(currentQuestion.id, option.value || option.score || index)}\n                                >\n                                    <span className={styles.optionLabel}>{option.label || option.text}</span>\n                                </button>\n                            ))}\n                        </div>\n                        \n                        {currentQuestion.insight && (\n                            <p className={styles.questionInsight}>{currentQuestion.insight}</p>\n                        )}\n                        \n                        {currentQuestion.benchmark && (\n                            <p className={styles.questionBenchmark}>{currentQuestion.benchmark}</p>\n                        )}\n                    </div>\n                )}\n\n                {/* Question navigation dots */}\n                <div className={styles.questionDots}>\n                    {questions.map((_, index) => (\n                        <button\n                            key={index}\n                            className={`${styles.dot} ${\n                                index === currentQuestionIndex ? styles.active : ''\n                            } ${getResponse(questions[index].id) ? styles.answered : ''}`}\n                            onClick={() => setCurrentQuestionIndex(index)}\n                            aria-label={`Go to question ${index + 1}`}\n                        />\n                    ))}\n                </div>\n            </div>\n\n            <Navigation\n                onBack={handlePrevious}\n                onNext={handleNext}\n                onSkip={currentQuestion?.required === false ? handleSkip : null}\n                nextLabel={isLastQuestion ? \"Complete\" : \"Continue\"}\n                showNext={true}\n            />\n        </div>\n    );\n};\n\nexport default DynamicQuestions;\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,SAASC,WAAW,QAAQ,eAAe;AAC3C,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,MAAM,MAAM,iCAAiC;;AAEpD;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,QAAQ,GAAGA,CAACC,OAAO,EAAEC,IAAI,KAAK;EAChCC,OAAO,CAACC,GAAG,CAAC,WAAWH,OAAO,GAAG,EAAEC,IAAI,CAAC;AAC5C,CAAC;AAED,MAAMG,gBAAgB,GAAGA,CAAC;EACtBC,cAAc;EACdC,YAAY;EACZC,WAAW;EACXC,UAAU;EACVC,UAAU;EACVC,UAAU;EACVC,MAAM;EACNC;AACJ,CAAC,KAAK;EAAAC,EAAA;EACF,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGvB,QAAQ,CAAC,EAAE,CAAC;EAC9C,MAAM,CAACwB,oBAAoB,EAAEC,uBAAuB,CAAC,GAAGzB,QAAQ,CAAC,CAAC,CAAC;EACnE,MAAM,CAAC0B,OAAO,EAAEC,UAAU,CAAC,GAAG3B,QAAQ,CAAC,IAAI,CAAC;EAE5CC,SAAS,CAAC,MAAM;IACZ2B,aAAa,CAAC,CAAC;EACnB,CAAC,EAAE,CAACf,cAAc,CAAC,CAAC;EAEpB,MAAMe,aAAa,GAAG,MAAAA,CAAA,KAAY;IAC9B,IAAI;MACAD,UAAU,CAAC,IAAI,CAAC;MAChBpB,QAAQ,CAAC,uCAAuC,EAAEM,cAAc,CAAC;;MAEjE;MACA,MAAMgB,MAAM,GAAG,MAAM,MAAM,CAAC,qBAAqBhB,cAAc,iBAAiB,CAAC;MACjF,MAAMJ,IAAI,GAAGoB,MAAM,CAACC,OAAO,IAAID,MAAM;;MAErC;MACA,IAAIE,aAAa,GAAG,EAAE;MACtB,IAAItB,IAAI,CAACa,SAAS,EAAE;QAChB;QACAS,aAAa,GAAGtB,IAAI,CAACa,SAAS;MAClC,CAAC,MAAM,IAAIb,IAAI,CAACsB,aAAa,EAAE;QAC3B;QACAC,MAAM,CAACC,MAAM,CAACxB,IAAI,CAACsB,aAAa,CAAC,CAACG,OAAO,CAACC,WAAW,IAAI;UACrD,IAAIC,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC,EAAE;YAC5BJ,aAAa,GAAG,CAAC,GAAGA,aAAa,EAAE,GAAGI,WAAW,CAAC;UACtD;QACJ,CAAC,CAAC;MACN;MACA5B,QAAQ,CAAC,uBAAuB,EAAEwB,aAAa,CAACO,MAAM,CAAC;;MAEvD;MACA,IAAIC,gBAAgB,GAAG,EAAE;;MAEzB;MACA,IAAIC,gBAAgB;MACpBjC,QAAQ,CAAC,gCAAgC,EAAE,EAAE,CAAC;MAE9C,IAAI;QACA;QACA,IAAI,OAAOS,UAAU,KAAK,UAAU,EAAE;UAClCT,QAAQ,CAAC,kCAAkC,EAAE,EAAE,CAAC;UAChDiC,gBAAgB,GAAGxB,UAAU,CAAC,kBAAkB,CAAC;UACjDT,QAAQ,CAAC,+BAA+B,EAAEiC,gBAAgB,CAAC;QAC/D,CAAC,MAAM;UACHjC,QAAQ,CAAC,8BAA8B,EAAE,EAAE,CAAC;QAChD;;QAEA;QACA,IAAI,CAACiC,gBAAgB,IAAI,OAAOzB,WAAW,KAAK,UAAU,EAAE;UACxDR,QAAQ,CAAC,yCAAyC,EAAE,EAAE,CAAC;UACvDiC,gBAAgB,GAAGzB,WAAW,CAAC,kBAAkB,CAAC;UAClDR,QAAQ,CAAC,iCAAiC,EAAEiC,gBAAgB,CAAC;QACjE;;QAEA;QACA,IAAIA,gBAAgB,EAAE;UAClBjC,QAAQ,CAAC,uBAAuB,EAAE,OAAOiC,gBAAgB,CAAC;UAC1DjC,QAAQ,CAAC,uBAAuB,EAAEyB,MAAM,CAACS,IAAI,CAACD,gBAAgB,CAAC,CAAC;UAChEjC,QAAQ,CAAC,yBAAyB,EAAEyB,MAAM,CAACC,MAAM,CAACO,gBAAgB,CAAC,CAAC;QACxE,CAAC,MAAM;UACHjC,QAAQ,CAAC,uCAAuC,EAAE,EAAE,CAAC;QACzD;MACJ,CAAC,CAAC,OAAOmC,GAAG,EAAE;QACVhC,OAAO,CAACiC,KAAK,CAAC,iCAAiC,EAAED,GAAG,CAAC;MACzD;MAEA,IAAIF,gBAAgB,IAAIR,MAAM,CAACS,IAAI,CAACD,gBAAgB,CAAC,CAACF,MAAM,GAAG,CAAC,EAAE;QAC9D,IAAI;UACA;UACA/B,QAAQ,CAAC,qCAAqC,EAAE,qBAAqBM,cAAc,yBAAyB,CAAC;UAE7G,MAAM+B,aAAa,GAAG,MAAM,MAAM,CAAC,qBAAqB/B,cAAc,yBAAyB,CAAC;UAChG,MAAMgC,WAAW,GAAGD,aAAa,CAACd,OAAO,IAAIc,aAAa;;UAE1D;UACA,IAAIC,WAAW,EAAE;YACbtC,QAAQ,CAAC,kCAAkC,EAAEyB,MAAM,CAACS,IAAI,CAACI,WAAW,CAAC,CAAC;;YAEtE;YACA;YACA,MAAMC,oBAAoB,GAAG,IAAI;;YAEjC;YACAd,MAAM,CAACS,IAAI,CAACD,gBAAgB,CAAC,CAACN,OAAO,CAACa,SAAS,IAAI;cAC/C,MAAMC,UAAU,GAAGR,gBAAgB,CAACO,SAAS,CAAC;cAE9C,IAAIC,UAAU,IAAIF,oBAAoB,EAAE;gBACpCvC,QAAQ,CAAC,WAAWwC,SAAS,eAAeC,UAAU,sBAAsBF,oBAAoB,EAAE,EAAE,EAAE,CAAC;;gBAEvG;gBACA;gBACA,IAAID,WAAW,CAACE,SAAS,CAAC,EAAE;kBACxBxC,QAAQ,CAAC,kCAAkCwC,SAAS,EAAE,EAAEF,WAAW,CAACE,SAAS,CAAC,CAACT,MAAM,IAAI,CAAC,CAAC;kBAC3FC,gBAAgB,GAAG,CAAC,GAAGA,gBAAgB,EAAE,IAAIM,WAAW,CAACE,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC/E;gBACA;gBAAA,KACK,IAAIF,WAAW,CAACvB,SAAS,EAAE;kBAC5B,MAAM2B,iBAAiB,GAAGJ,WAAW,CAACvB,SAAS,CAAC4B,MAAM,CAACC,CAAC,IACpDA,CAAC,CAACC,UAAU,KAAKL,SAAS,IAAII,CAAC,CAACJ,SAAS,KAAKA,SAClD,CAAC;kBACDxC,QAAQ,CAAC,SAAS0C,iBAAiB,CAACX,MAAM,8BAA8BS,SAAS,EAAE,EAAE,EAAE,CAAC;kBACxFR,gBAAgB,GAAG,CAAC,GAAGA,gBAAgB,EAAE,GAAGU,iBAAiB,CAAC;gBAClE;gBACA;gBAAA,KACK;kBACD;kBACA,IAAII,UAAU,GAAG,KAAK;;kBAEtB;kBACArB,MAAM,CAACS,IAAI,CAACI,WAAW,CAAC,CAACX,OAAO,CAACoB,GAAG,IAAI;oBACpC;oBACA,IACIA,GAAG,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACT,SAAS,CAACQ,WAAW,CAAC,CAAC,CAAC,IACnDR,SAAS,CAACQ,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACF,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC,EACrD;sBACE,MAAMjC,SAAS,GAAGuB,WAAW,CAACS,GAAG,CAAC;sBAClC,IAAIlB,KAAK,CAACC,OAAO,CAACf,SAAS,CAAC,EAAE;wBAC1Bf,QAAQ,CAAC,SAASe,SAAS,CAACgB,MAAM,8BAA8BgB,GAAG,aAAaP,SAAS,EAAE,EAAE,EAAE,CAAC;wBAChGR,gBAAgB,GAAG,CAAC,GAAGA,gBAAgB,EAAE,GAAGjB,SAAS,CAAC;wBACtD+B,UAAU,GAAG,IAAI;sBACrB;oBACJ;kBACJ,CAAC,CAAC;kBAEF,IAAI,CAACA,UAAU,EAAE;oBACb9C,QAAQ,CAAC,wCAAwCwC,SAAS,oBAAoB,EAAEf,MAAM,CAACS,IAAI,CAACI,WAAW,CAAC,CAAC;kBAC7G;gBACJ;cACJ,CAAC,MAAM;gBACHtC,QAAQ,CAAC,WAAWwC,SAAS,eAAeC,UAAU,oBAAoBF,oBAAoB,EAAE,EAAE,EAAE,CAAC;cACzG;YACJ,CAAC,CAAC;UACN,CAAC,MAAM;YACHvC,QAAQ,CAAC,kCAAkC,EAAEsC,WAAW,CAAC;UAC7D;QACJ,CAAC,CAAC,OAAOF,KAAK,EAAE;UACZjC,OAAO,CAACiC,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;QAC5D;MACJ,CAAC,MAAM;QACHjC,OAAO,CAAC+C,IAAI,CAAC,0DAA0D,EAAEjB,gBAAgB,CAAC;MAC9F;MAEAjC,QAAQ,CAAC,kCAAkC,EAAEgC,gBAAgB,CAACD,MAAM,CAAC;;MAErE;MACA,MAAMoB,eAAe,GAAG,EAAE;MAC1B,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;;MAE7B;MACA7B,aAAa,CAACG,OAAO,CAACiB,CAAC,IAAI;QACvB,IAAI,CAACQ,WAAW,CAACE,GAAG,CAACV,CAAC,CAACW,EAAE,CAAC,EAAE;UACxBH,WAAW,CAACI,GAAG,CAACZ,CAAC,CAACW,EAAE,CAAC;UACrBJ,eAAe,CAACM,IAAI,CAACb,CAAC,CAAC;QAC3B;MACJ,CAAC,CAAC;;MAEF;MACAZ,gBAAgB,CAACL,OAAO,CAACiB,CAAC,IAAI;QAC1B,IAAI,CAACQ,WAAW,CAACE,GAAG,CAACV,CAAC,CAACW,EAAE,CAAC,EAAE;UACxBH,WAAW,CAACI,GAAG,CAACZ,CAAC,CAACW,EAAE,CAAC;UACrBJ,eAAe,CAACM,IAAI,CAACb,CAAC,CAAC;QAC3B;MACJ,CAAC,CAAC;MAEF5C,QAAQ,CAAC,mCAAmC,EAAEmD,eAAe,CAACpB,MAAM,CAAC;MACrE/B,QAAQ,CAAC,cAAc,EAAE6B,KAAK,CAAC6B,IAAI,CAACN,WAAW,CAAC,CAAC;MAEjDpC,YAAY,CAACmC,eAAe,CAAC;IACjC,CAAC,CAAC,OAAOf,KAAK,EAAE;MACZjC,OAAO,CAACiC,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACrD,CAAC,SAAS;MACNhB,UAAU,CAAC,KAAK,CAAC;IACrB;EACJ,CAAC;EAED,MAAMuC,eAAe,GAAG5C,SAAS,CAACE,oBAAoB,CAAC;EACvD,MAAM2C,cAAc,GAAG3C,oBAAoB,KAAKF,SAAS,CAACgB,MAAM,GAAG,CAAC;EAEpE,MAAM8B,YAAY,GAAGA,CAACC,UAAU,EAAEC,KAAK,KAAK;IACxC;IACAxD,YAAY,CAACuD,UAAU,EAAEC,KAAK,CAAC;;IAE/B;IACAC,UAAU,CAAC,MAAM;MACb,IAAI/C,oBAAoB,GAAGF,SAAS,CAACgB,MAAM,GAAG,CAAC,EAAE;QAC7Cb,uBAAuB,CAACD,oBAAoB,GAAG,CAAC,CAAC;MACrD;IACJ,CAAC,EAAE,GAAG,CAAC;EACX,CAAC;EAED,MAAMgD,UAAU,GAAGA,CAAA,KAAM;IACrB;IACA,MAAMC,QAAQ,GAAGnD,SAAS,CAACE,oBAAoB,CAAC;IAChD,IAAIiD,QAAQ,IAAIA,QAAQ,CAACC,QAAQ,KAAK,KAAK,IAAI,CAAC3D,WAAW,CAAC0D,QAAQ,CAACX,EAAE,CAAC,EAAE;MACtEa,KAAK,CAAC,+CAA+C,CAAC;MACtD;IACJ;IAEA,IAAIR,cAAc,EAAE;MAChB;MACA,IAAI,OAAOnD,UAAU,KAAK,UAAU,EAAE;QAClC,MAAMwB,gBAAgB,GAAGxB,UAAU,CAAC,kBAAkB,CAAC;QACvD,IAAIwB,gBAAgB,IAAI,OAAO1B,YAAY,KAAK,UAAU,EAAE;UACxD;UACAA,YAAY,CAAC,kBAAkB,EAAE0B,gBAAgB,CAAC;UAClDjC,QAAQ,CAAC,+CAA+C,EAAEiC,gBAAgB,CAAC;QAC/E;MACJ;;MAEA;MACA,IAAItB,UAAU,EAAE;QACZA,UAAU,CAAC,CAAC;MAChB;IACJ,CAAC,MAAM;MACHO,uBAAuB,CAACmD,IAAI,IAAIA,IAAI,GAAG,CAAC,CAAC;IAC7C;EACJ,CAAC;EAED,MAAMC,cAAc,GAAGA,CAAA,KAAM;IACzB,IAAIrD,oBAAoB,GAAG,CAAC,EAAE;MAC1BC,uBAAuB,CAACmD,IAAI,IAAIA,IAAI,GAAG,CAAC,CAAC;IAC7C,CAAC,MAAM;MACH;MACAzD,MAAM,CAAC,CAAC;IACZ;EACJ,CAAC;EAED,MAAM2D,UAAU,GAAGA,CAAA,KAAM;IACrBN,UAAU,CAAC,CAAC;EAChB,CAAC;EAED,IAAI9C,OAAO,EAAE;IACT,oBACIpB,OAAA;MAAKyE,SAAS,EAAE3E,MAAM,CAAC4E,gBAAiB;MAAAC,QAAA,gBACpC3E,OAAA;QAAKyE,SAAS,EAAE3E,MAAM,CAAC8E;MAAQ;QAAAC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC,eAClChF,OAAA;QAAA2E,QAAA,EAAG;MAAoB;QAAAE,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC1B,CAAC;EAEd;EAEA,IAAI,CAACpB,eAAe,EAAE;IAClB,oBACI5D,OAAA;MAAKyE,SAAS,EAAE3E,MAAM,CAACmF,cAAe;MAAAN,QAAA,gBAClC3E,OAAA;QAAA2E,QAAA,EAAG;MAA2C;QAAAE,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAG,CAAC,eAClDhF,OAAA;QAAQkF,OAAO,EAAErE,MAAO;QAAA8D,QAAA,EAAC;MAAO;QAAAE,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACxC,CAAC;EAEd;EAEA,MAAMG,aAAa,GAAG1E,WAAW,CAACmD,eAAe,CAACJ,EAAE,CAAC;EAErD,oBACIxD,OAAA;IAAKyE,SAAS,EAAE3E,MAAM,CAACsF,mBAAoB;IAAAT,QAAA,gBACvC3E,OAAA,CAACJ,WAAW;MAACkB,QAAQ,EAAEA,QAAQ,IAAI,EAAG;MAACuE,KAAK,EAAC;IAAY;MAAAR,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,eAE5DhF,OAAA;MAAKyE,SAAS,EAAE3E,MAAM,CAACwF,iBAAkB;MAAAX,QAAA,gBACrC3E,OAAA;QAAKyE,SAAS,EAAE3E,MAAM,CAACyF,cAAe;QAAAZ,QAAA,gBAClC3E,OAAA;UAAA2E,QAAA,EAAI;QAA4B;UAAAE,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAI,CAAC,eACrChF,OAAA;UAAGyE,SAAS,EAAE3E,MAAM,CAAC0F,cAAe;UAAAb,QAAA,GAAC,WACxB,EAACzD,oBAAoB,GAAG,CAAC,EAAC,MAAI,EAACF,SAAS,CAACgB,MAAM;QAAA;UAAA6C,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACzD,CAAC;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC,EAELpB,eAAe,iBACZ5D,OAAA;QAAKyE,SAAS,EAAE3E,MAAM,CAAC2F,eAAgB;QAAAd,QAAA,gBACnC3E,OAAA;UAAIyE,SAAS,EAAE3E,MAAM,CAAC4F,YAAa;UAAAf,QAAA,GAC9Bf,eAAe,CAAC+B,QAAQ,IAAI/B,eAAe,CAACgC,IAAI,EAChDhC,eAAe,CAACQ,QAAQ,KAAK,KAAK,iBAAIpE,OAAA;YAAMyE,SAAS,EAAE3E,MAAM,CAACsE,QAAS;YAAAO,QAAA,EAAC;UAAC;YAAAE,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAM,CAAC;QAAA;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACjF,CAAC,eAELhF,OAAA;UAAKyE,SAAS,EAAE3E,MAAM,CAAC+F,WAAY;UAAAlB,QAAA,EAC9Bf,eAAe,CAACkC,OAAO,CAACC,GAAG,CAAC,CAACC,MAAM,EAAEC,KAAK,kBACvCjG,OAAA;YAEIyE,SAAS,EAAE,GAAG3E,MAAM,CAACoG,YAAY,IAC7Bf,aAAa,MAAMa,MAAM,CAAChC,KAAK,IAAIgC,MAAM,CAACG,KAAK,IAAIF,KAAK,CAAC,GAAGnG,MAAM,CAACsG,QAAQ,GAAG,EAAE,EACjF;YACHlB,OAAO,EAAEA,CAAA,KAAMpB,YAAY,CAACF,eAAe,CAACJ,EAAE,EAAEwC,MAAM,CAAChC,KAAK,IAAIgC,MAAM,CAACG,KAAK,IAAIF,KAAK,CAAE;YAAAtB,QAAA,eAEvF3E,OAAA;cAAMyE,SAAS,EAAE3E,MAAM,CAACuG,WAAY;cAAA1B,QAAA,EAAEqB,MAAM,CAACM,KAAK,IAAIN,MAAM,CAACJ;YAAI;cAAAf,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAO;UAAC,GANpEiB,KAAK;YAAApB,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAON,CACX;QAAC;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACD,CAAC,EAELpB,eAAe,CAAC2C,OAAO,iBACpBvG,OAAA;UAAGyE,SAAS,EAAE3E,MAAM,CAAC0G,eAAgB;UAAA7B,QAAA,EAAEf,eAAe,CAAC2C;QAAO;UAAA1B,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAI,CACrE,EAEApB,eAAe,CAAC6C,SAAS,iBACtBzG,OAAA;UAAGyE,SAAS,EAAE3E,MAAM,CAAC4G,iBAAkB;UAAA/B,QAAA,EAAEf,eAAe,CAAC6C;QAAS;UAAA5B,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAI,CACzE;MAAA;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACA,CACR,eAGDhF,OAAA;QAAKyE,SAAS,EAAE3E,MAAM,CAAC6G,YAAa;QAAAhC,QAAA,EAC/B3D,SAAS,CAAC+E,GAAG,CAAC,CAACa,CAAC,EAAEX,KAAK,kBACpBjG,OAAA;UAEIyE,SAAS,EAAE,GAAG3E,MAAM,CAAC+G,GAAG,IACpBZ,KAAK,KAAK/E,oBAAoB,GAAGpB,MAAM,CAACgH,MAAM,GAAG,EAAE,IACnDrG,WAAW,CAACO,SAAS,CAACiF,KAAK,CAAC,CAACzC,EAAE,CAAC,GAAG1D,MAAM,CAACiH,QAAQ,GAAG,EAAE,EAAG;UAC9D7B,OAAO,EAAEA,CAAA,KAAM/D,uBAAuB,CAAC8E,KAAK,CAAE;UAC9C,cAAY,kBAAkBA,KAAK,GAAG,CAAC;QAAG,GALrCA,KAAK;UAAApB,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAMb,CACJ;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACD,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACL,CAAC,eAENhF,OAAA,CAACH,UAAU;MACPgB,MAAM,EAAE0D,cAAe;MACvByC,MAAM,EAAE9C,UAAW;MACnB+C,MAAM,EAAE,CAAArD,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEQ,QAAQ,MAAK,KAAK,GAAGI,UAAU,GAAG,IAAK;MAChE0C,SAAS,EAAErD,cAAc,GAAG,UAAU,GAAG,UAAW;MACpDsD,QAAQ,EAAE;IAAK;MAAAtC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAClB,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACD,CAAC;AAEd,CAAC;AAACjE,EAAA,CA1UIT,gBAAgB;AAAA8G,EAAA,GAAhB9G,gBAAgB;AA4UtB,eAAeA,gBAAgB;AAAC,IAAA8G,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}