{"ast":null,"code":"var _jsxFileName = \"/Users/jon/Documents/GitHub/assessor/src/core/components/DynamicQuestions.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { ProgressBar } from './ProgressBar';\nimport Navigation from './Navigation';\nimport styles from '../styles/components.module.css';\n\n// Debug helper function\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst debugLog = (message, data) => {\n  console.log(`DEBUG - ${message}:`, data);\n};\nconst DynamicQuestions = ({\n  assessmentType,\n  saveResponse,\n  getResponse,\n  getContext,\n  setContext,\n  onComplete,\n  onBack,\n  progress\n}) => {\n  _s();\n  const [questions, setQuestions] = useState([]);\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\n  const [loading, setLoading] = useState(true);\n  useEffect(() => {\n    loadQuestions();\n  }, [assessmentType]);\n  const loadQuestions = async () => {\n    try {\n      setLoading(true);\n      console.log(`ðŸ” [${assessmentType}] LOADING QUESTIONS - DEBUGGING ISSUE`);\n      debugLog('Loading questions for assessment type', assessmentType);\n\n      // Load core questions\n      let coreQuestions = [];\n      let categoryQuestionCounts = {};\n\n      // Function to recursively extract questions from nested structure\n      const extractQuestionsFromNestedObject = (obj, path = '') => {\n        let extractedQuestions = [];\n\n        // Base case: If it's an array, we assume it's an array of questions\n        if (Array.isArray(obj)) {\n          console.log(`ðŸ”¢ Found ${obj.length} questions array at path: ${path}`);\n          // Count questions per category for debugging\n          if (path) {\n            categoryQuestionCounts[path] = obj.length;\n          }\n          return obj;\n        }\n\n        // If it's an object, traverse its properties\n        if (obj && typeof obj === 'object') {\n          for (const key in obj) {\n            const newPath = path ? `${path}.${key}` : key;\n            if (Array.isArray(obj[key])) {\n              // Found an array, add its items to our questions\n              console.log(`ðŸ”¢ Found ${obj[key].length} questions in ${newPath}`);\n              categoryQuestionCounts[newPath] = obj[key].length;\n              extractedQuestions = extractedQuestions.concat(obj[key]);\n            } else if (obj[key] && typeof obj[key] === 'object') {\n              // Found a nested object, recursively extract questions from it\n              const nestedQuestions = extractQuestionsFromNestedObject(obj[key], newPath);\n              if (nestedQuestions.length > 0) {\n                console.log(`âž• Adding ${nestedQuestions.length} questions from ${newPath}`);\n                extractedQuestions = extractedQuestions.concat(nestedQuestions);\n              }\n            }\n          }\n        }\n        return extractedQuestions;\n      };\n      try {\n        const coreModule = await import(`../../assessments/${assessmentType}/questions.json`);\n        const coreData = coreModule.default || coreModule;\n        console.log(`ðŸ“ [${assessmentType}] Core questions data structure:`, Object.keys(coreData));\n\n        // Handle different possible structures\n        if (Array.isArray(coreData)) {\n          // Direct array structure\n          coreQuestions = coreData;\n          console.log(`ðŸ“Š Loaded ${coreQuestions.length} core questions (direct array)`);\n        } else if (coreData.coreQuestions) {\n          // Structure with coreQuestions property\n          if (Array.isArray(coreData.coreQuestions)) {\n            // coreQuestions is a direct array\n            coreQuestions = coreData.coreQuestions;\n            console.log(`ðŸ“Š Loaded ${coreQuestions.length} core questions from coreQuestions array`);\n          } else {\n            // coreQuestions is an object with nested question arrays\n            console.log(`ðŸ” Extracting questions from nested coreQuestions object with categories:`, Object.keys(coreData.coreQuestions));\n\n            // First, let's log all the categories and their question counts\n            for (const category in coreData.coreQuestions) {\n              if (Array.isArray(coreData.coreQuestions[category])) {\n                console.log(`ðŸ“Š Category ${category} has ${coreData.coreQuestions[category].length} direct questions`);\n              } else if (typeof coreData.coreQuestions[category] === 'object') {\n                console.log(`ðŸ” Category ${category} has nested structure:`, Object.keys(coreData.coreQuestions[category]));\n              }\n            }\n            coreQuestions = extractQuestionsFromNestedObject(coreData.coreQuestions, 'coreQuestions');\n            console.log(`ðŸ“Š Category question counts:`, categoryQuestionCounts);\n            console.log(`ðŸ“Š Total extracted core questions: ${coreQuestions.length}`);\n\n            // Verify by listing all question IDs\n            const coreQuestionIds = coreQuestions.map(q => q.id);\n            console.log(`ðŸ†” Core question IDs:`, coreQuestionIds);\n          }\n        } else {\n          // Try to extract questions from the entire object\n          coreQuestions = extractQuestionsFromNestedObject(coreData);\n          console.log(`ðŸ“Š Extracted ${coreQuestions.length} questions from entire data object`);\n        }\n        if (coreQuestions.length === 0) {\n          console.error(`âŒ Could not find questions array in core data structure:`, Object.keys(coreData));\n        }\n      } catch (error) {\n        console.error(`âŒ Error loading core questions for ${assessmentType}:`, error);\n      }\n      console.log(`ðŸ“Š Loaded ${coreQuestions.length} core questions`);\n\n      // If we have selected services, load service-specific questions\n      let serviceQuestions = [];\n\n      // Get selected services from context or responses\n      let selectedServices;\n      try {\n        selectedServices = getContext('selectedServices');\n        debugLog('Retrieved selectedServices from context', selectedServices);\n\n        // If not in context, try to get from responses\n        if (!selectedServices || Object.keys(selectedServices).length === 0) {\n          const servicesResponse = getResponse('selectedServices');\n          if (servicesResponse) {\n            selectedServices = servicesResponse;\n            debugLog('Retrieved selectedServices from responses', selectedServices);\n          }\n        }\n      } catch (err) {\n        console.error('Error getting selectedServices:', err);\n      }\n\n      // Process service-specific questions if services are selected\n      if (selectedServices && Object.keys(selectedServices).length > 0) {\n        try {\n          // Load service-specific questions - handle different file names based on assessment type\n          let serviceData;\n          try {\n            // First try to load from service-questions.json (agency-vulnerability)\n            debugLog(`Trying to load service questions from`, `../../assessments/${assessmentType}/service-questions.json`);\n            const serviceModule = await import(`../../assessments/${assessmentType}/service-questions.json`);\n            serviceData = serviceModule.default || serviceModule;\n            debugLog('Loaded service questions from service-questions.json', Object.keys(serviceData));\n          } catch (error) {\n            // If that fails, try activity-questions.json (inhouse-marketing)\n            debugLog(`First attempt failed, trying activity-questions.json`, error.message);\n            try {\n              debugLog(`Loading activity questions from`, `../../assessments/${assessmentType}/activity-questions.json`);\n              const activityModule = await import(`../../assessments/${assessmentType}/activity-questions.json`);\n              serviceData = activityModule.default || activityModule;\n              debugLog('Loaded service questions from activity-questions.json', Object.keys(serviceData));\n            } catch (activityError) {\n              debugLog('Failed to load both service-questions.json and activity-questions.json', activityError.message);\n              // Don't throw, just continue with empty service questions\n              serviceData = null;\n            }\n          }\n\n          // Extract service questions if service data was loaded\n          if (serviceData) {\n            debugLog('Service questions data structure', Object.keys(serviceData));\n\n            // Determine the property containing service questions\n            const serviceQuestionsData = serviceData.serviceQuestions || serviceData.activityQuestions || {};\n            debugLog('Service/activity questions nested structure', Object.keys(serviceQuestionsData));\n\n            // Define mappings from selected service IDs to question categories\n            const serviceIdMappings = {\n              // Agency mappings\n              'content_creation': ['content_creation', 'content_marketing'],\n              'creative_design': ['content_creation', 'creative_design'],\n              'digital_marketing': ['content_creation', 'digital_marketing'],\n              'seo_sem': ['content_creation', 'seo_sem'],\n              'pr_comms': ['content_creation', 'strategy_consulting', 'pr_comms'],\n              'web_development': ['strategy_consulting', 'web_development'],\n              'social_media': ['content_creation', 'social_media'],\n              // Inhouse mappings - direct matches to activity names\n              'content_marketing': ['content_marketing'],\n              'email_marketing': ['email_marketing'],\n              'paid_advertising': ['paid_advertising'],\n              'analytics_data': ['analytics_data'],\n              'marketing_automation': ['marketing_automation']\n            };\n\n            // Process each selected service\n            const ALLOCATION_THRESHOLD = 0.05; // 5% threshold\n\n            Object.keys(selectedServices).forEach(serviceId => {\n              const allocation = selectedServices[serviceId];\n              if (allocation >= ALLOCATION_THRESHOLD) {\n                debugLog(`Service ${serviceId} allocation ${allocation} exceeds threshold`, '');\n\n                // Get the mapped question categories for this service ID\n                const mappedCategories = serviceIdMappings[serviceId] || [serviceId];\n                debugLog(`Service ${serviceId} maps to categories`, mappedCategories);\n\n                // Process each mapped category\n                let foundQuestionsForService = false;\n                mappedCategories.forEach(mappedId => {\n                  // Check if there's a direct match in serviceQuestionsData\n                  if (serviceQuestionsData[mappedId]) {\n                    const serviceObj = serviceQuestionsData[mappedId];\n\n                    // Handle both structures: nested 'questions' array or direct array\n                    if (serviceObj.questions && Array.isArray(serviceObj.questions)) {\n                      serviceQuestions = [...serviceQuestions, ...serviceObj.questions];\n                      debugLog(`Found ${serviceObj.questions.length} questions for service ID ${mappedId}`, '');\n                      foundQuestionsForService = true;\n                    } else if (Array.isArray(serviceObj)) {\n                      serviceQuestions = [...serviceQuestions, ...serviceObj];\n                      debugLog(`Found ${serviceObj.length} questions for service ID ${mappedId}`, '');\n                      foundQuestionsForService = true;\n                    } else if (typeof serviceObj === 'object') {\n                      // Try to extract questions from nested structure\n                      const extractedQuestions = extractQuestionsFromNestedObject(serviceObj, mappedId);\n                      if (extractedQuestions.length > 0) {\n                        serviceQuestions = [...serviceQuestions, ...extractedQuestions];\n                        debugLog(`Extracted ${extractedQuestions.length} questions from nested service object ${mappedId}`, '');\n                        foundQuestionsForService = true;\n                      }\n                    }\n                  } else {\n                    // Try fuzzy matching by service name\n                    Object.keys(serviceQuestionsData).forEach(key => {\n                      if (key.toLowerCase().includes(mappedId.toLowerCase()) || mappedId.toLowerCase().includes(key.toLowerCase())) {\n                        const serviceObj = serviceQuestionsData[key];\n                        if (serviceObj.questions && Array.isArray(serviceObj.questions)) {\n                          serviceQuestions = [...serviceQuestions, ...serviceObj.questions];\n                          debugLog(`Found ${serviceObj.questions.length} questions for similar key ${key}`, '');\n                          foundQuestionsForService = true;\n                        } else if (Array.isArray(serviceObj)) {\n                          serviceQuestions = [...serviceQuestions, ...serviceObj];\n                          debugLog(`Found ${serviceObj.length} questions for similar key ${key}`, '');\n                          foundQuestionsForService = true;\n                        }\n                      }\n                    });\n                  }\n                });\n                if (!foundQuestionsForService) {\n                  debugLog(`Could not find any questions for service ${serviceId}`, '');\n                }\n              }\n            });\n          }\n        } catch (error) {\n          console.error('Error loading service questions:', error);\n        }\n      } else {\n        console.warn('No services selected or invalid selectedServices format:', selectedServices);\n      }\n      debugLog(`Found service-specific questions`, serviceQuestions.length);\n\n      // Remove any potential duplicate questions by ID and validate questions\n      const uniqueQuestions = [];\n      const questionIds = new Set();\n\n      // Process core questions first\n      coreQuestions.forEach(q => {\n        if (q && q.id && !questionIds.has(q.id)) {\n          // Ensure question has all required properties\n          if (!q.options || !Array.isArray(q.options) || q.options.length === 0) {\n            debugLog(`Skipping invalid question without options:`, q.id);\n            return;\n          }\n          questionIds.add(q.id);\n          uniqueQuestions.push(q);\n        }\n      });\n\n      // Then add service questions, avoiding duplicates\n      serviceQuestions.forEach(q => {\n        if (q && q.id && !questionIds.has(q.id)) {\n          // Ensure question has all required properties\n          if (!q.options || !Array.isArray(q.options) || q.options.length === 0) {\n            debugLog(`Skipping invalid service question without options:`, q.id);\n            return;\n          }\n          questionIds.add(q.id);\n          uniqueQuestions.push(q);\n        }\n      });\n      debugLog(`Total unique questions to display`, uniqueQuestions.length);\n      debugLog('Question IDs', Array.from(questionIds));\n      setQuestions(uniqueQuestions);\n    } catch (error) {\n      console.error('Failed to load questions:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  const currentQuestion = questions[currentQuestionIndex];\n  const isLastQuestion = currentQuestionIndex === questions.length - 1;\n  const handleAnswer = (questionId, value) => {\n    // Save the answer\n    saveResponse(questionId, value);\n\n    // Log the answer being saved for debugging\n    debugLog(`Saving answer for question ${questionId}:`, value);\n\n    // Try to retrieve all saved answers\n    if (typeof getResponse === 'function') {\n      const allAnswers = {};\n      questions.forEach(q => {\n        const answer = getResponse(q.id);\n        if (answer !== undefined) {\n          allAnswers[q.id] = answer;\n        }\n      });\n      debugLog('Current saved answers:', allAnswers);\n    }\n\n    // Auto-advance to next question after a short delay\n    setTimeout(() => {\n      if (currentQuestionIndex < questions.length - 1) {\n        setCurrentQuestionIndex(currentQuestionIndex + 1);\n      }\n    }, 300);\n  };\n  const handleNext = () => {\n    // Validate if the current question is answered\n    const currentQ = questions[currentQuestionIndex];\n    if (currentQ && currentQ.required !== false && !getResponse(currentQ.id)) {\n      alert('Please answer this question before continuing');\n      return;\n    }\n    if (isLastQuestion) {\n      // Collect and log all answers for debugging\n      const allAnswers = {};\n      questions.forEach(q => {\n        const answer = getResponse(q.id);\n        if (answer !== undefined) {\n          allAnswers[q.id] = answer;\n        }\n      });\n      debugLog('FINAL ANSWERS being submitted:', allAnswers);\n      debugLog('Number of answered questions:', Object.keys(allAnswers).length);\n      debugLog('Total questions:', questions.length);\n\n      // Before completing, ensure selectedServices is stored in both context and responses\n      if (typeof getContext === 'function') {\n        const selectedServices = getContext('selectedServices');\n        if (selectedServices && typeof saveResponse === 'function') {\n          // Save as a response to ensure it's available in both places\n          saveResponse('selectedServices', selectedServices);\n          debugLog('Saved selectedServices to responses as backup', selectedServices);\n        }\n      }\n\n      // Set a global flag to indicate this component has completed with answers\n      if (typeof window !== 'undefined') {\n        window.dynamicQuestionsCompleted = true;\n        window.dynamicQuestionsAnswerCount = Object.keys(allAnswers).length;\n      }\n\n      // Move to the next stage using onComplete callback\n      if (onComplete) {\n        onComplete();\n      }\n    } else {\n      setCurrentQuestionIndex(prev => prev + 1);\n    }\n  };\n  const handlePrevious = () => {\n    if (currentQuestionIndex > 0) {\n      setCurrentQuestionIndex(prev => prev - 1);\n    } else {\n      // Go back to the previous stage in the assessment flow\n      onBack();\n    }\n  };\n  const handleSkip = () => {\n    handleNext();\n  };\n  if (loading) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.loadingContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.spinner\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 414,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Loading questions...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 415,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 413,\n      columnNumber: 13\n    }, this);\n  }\n  if (!currentQuestion) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.errorContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"No questions available for this assessment.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 423,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: onBack,\n        children: \"Go Back\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 424,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 422,\n      columnNumber: 13\n    }, this);\n  }\n  const selectedValue = getResponse(currentQuestion.id);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: styles.qualifyingContainer,\n    children: [/*#__PURE__*/_jsxDEV(ProgressBar, {\n      progress: progress || 65,\n      stage: \"assessment\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 433,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.questionContainer,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.questionHeader,\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: \"Your Organization Assessment\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 437,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: styles.questionNumber,\n          children: [\"Question \", currentQuestionIndex + 1, \" of \", questions.length]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 438,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 436,\n        columnNumber: 17\n      }, this), currentQuestion && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.questionContent,\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          className: styles.questionText,\n          children: [currentQuestion.question || currentQuestion.text, currentQuestion.required !== false && /*#__PURE__*/_jsxDEV(\"span\", {\n            className: styles.required,\n            children: \"*\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 447,\n            columnNumber: 68\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 445,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: styles.optionsGrid,\n          children: currentQuestion.options.map((option, index) => /*#__PURE__*/_jsxDEV(\"button\", {\n            className: `${styles.optionButton} ${selectedValue === (option.value || option.score || index) ? styles.selected : ''}`,\n            onClick: () => handleAnswer(currentQuestion.id, option.value || option.score || index),\n            children: /*#__PURE__*/_jsxDEV(\"span\", {\n              className: styles.optionLabel,\n              children: option.label || option.text\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 459,\n              columnNumber: 37\n            }, this)\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 452,\n            columnNumber: 33\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 450,\n          columnNumber: 25\n        }, this), currentQuestion.insight && /*#__PURE__*/_jsxDEV(\"p\", {\n          className: styles.questionInsight,\n          children: currentQuestion.insight\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 465,\n          columnNumber: 29\n        }, this), currentQuestion.benchmark && /*#__PURE__*/_jsxDEV(\"p\", {\n          className: styles.questionBenchmark,\n          children: currentQuestion.benchmark\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 469,\n          columnNumber: 29\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 21\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: styles.questionDots,\n        children: questions.map((_, index) => /*#__PURE__*/_jsxDEV(\"button\", {\n          className: `${styles.dot} ${index === currentQuestionIndex ? styles.active : ''} ${getResponse(questions[index].id) ? styles.answered : ''}`,\n          onClick: () => setCurrentQuestionIndex(index),\n          \"aria-label\": `Go to question ${index + 1}`\n        }, index, false, {\n          fileName: _jsxFileName,\n          lineNumber: 477,\n          columnNumber: 25\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 475,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 435,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Navigation, {\n      onBack: handlePrevious,\n      onNext: handleNext,\n      onSkip: (currentQuestion === null || currentQuestion === void 0 ? void 0 : currentQuestion.required) === false ? handleSkip : null,\n      nextLabel: isLastQuestion ? \"Complete\" : \"Continue\",\n      showNext: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 489,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 432,\n    columnNumber: 9\n  }, this);\n};\n_s(DynamicQuestions, \"hJiJQOXcC+XQPaBxuPtmnYbXKjw=\");\n_c = DynamicQuestions;\nexport default DynamicQuestions;\nvar _c;\n$RefreshReg$(_c, \"DynamicQuestions\");","map":{"version":3,"names":["React","useState","useEffect","ProgressBar","Navigation","styles","jsxDEV","_jsxDEV","debugLog","message","data","console","log","DynamicQuestions","assessmentType","saveResponse","getResponse","getContext","setContext","onComplete","onBack","progress","_s","questions","setQuestions","currentQuestionIndex","setCurrentQuestionIndex","loading","setLoading","loadQuestions","coreQuestions","categoryQuestionCounts","extractQuestionsFromNestedObject","obj","path","extractedQuestions","Array","isArray","length","key","newPath","concat","nestedQuestions","coreModule","coreData","default","Object","keys","category","coreQuestionIds","map","q","id","error","serviceQuestions","selectedServices","servicesResponse","err","serviceData","serviceModule","activityModule","activityError","serviceQuestionsData","activityQuestions","serviceIdMappings","ALLOCATION_THRESHOLD","forEach","serviceId","allocation","mappedCategories","foundQuestionsForService","mappedId","serviceObj","toLowerCase","includes","warn","uniqueQuestions","questionIds","Set","has","options","add","push","from","currentQuestion","isLastQuestion","handleAnswer","questionId","value","allAnswers","answer","undefined","setTimeout","handleNext","currentQ","required","alert","window","dynamicQuestionsCompleted","dynamicQuestionsAnswerCount","prev","handlePrevious","handleSkip","className","loadingContainer","children","spinner","fileName","_jsxFileName","lineNumber","columnNumber","errorContainer","onClick","selectedValue","qualifyingContainer","stage","questionContainer","questionHeader","questionNumber","questionContent","questionText","question","text","optionsGrid","option","index","optionButton","score","selected","optionLabel","label","insight","questionInsight","benchmark","questionBenchmark","questionDots","_","dot","active","answered","onNext","onSkip","nextLabel","showNext","_c","$RefreshReg$"],"sources":["/Users/jon/Documents/GitHub/assessor/src/core/components/DynamicQuestions.jsx"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { ProgressBar } from './ProgressBar';\nimport Navigation from './Navigation';\nimport styles from '../styles/components.module.css';\n\n// Debug helper function\nconst debugLog = (message, data) => {\n    console.log(`DEBUG - ${message}:`, data);\n};\n\nconst DynamicQuestions = ({ \n    assessmentType, \n    saveResponse, \n    getResponse, \n    getContext,\n    setContext, \n    onComplete,\n    onBack,\n    progress\n}) => {\n    const [questions, setQuestions] = useState([]);\n    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        loadQuestions();\n    }, [assessmentType]);\n\n    const loadQuestions = async () => {\n        try {\n            setLoading(true);\n            console.log(`ðŸ” [${assessmentType}] LOADING QUESTIONS - DEBUGGING ISSUE`);\n            debugLog('Loading questions for assessment type', assessmentType);\n            \n            // Load core questions\n            let coreQuestions = [];\n            let categoryQuestionCounts = {};\n            \n            // Function to recursively extract questions from nested structure\n            const extractQuestionsFromNestedObject = (obj, path = '') => {\n                let extractedQuestions = [];\n                \n                // Base case: If it's an array, we assume it's an array of questions\n                if (Array.isArray(obj)) {\n                    console.log(`ðŸ”¢ Found ${obj.length} questions array at path: ${path}`);\n                    // Count questions per category for debugging\n                    if (path) {\n                        categoryQuestionCounts[path] = obj.length;\n                    }\n                    return obj;\n                }\n                \n                // If it's an object, traverse its properties\n                if (obj && typeof obj === 'object') {\n                    for (const key in obj) {\n                        const newPath = path ? `${path}.${key}` : key;\n                        \n                        if (Array.isArray(obj[key])) {\n                            // Found an array, add its items to our questions\n                            console.log(`ðŸ”¢ Found ${obj[key].length} questions in ${newPath}`);\n                            categoryQuestionCounts[newPath] = obj[key].length;\n                            extractedQuestions = extractedQuestions.concat(obj[key]);\n                        } else if (obj[key] && typeof obj[key] === 'object') {\n                            // Found a nested object, recursively extract questions from it\n                            const nestedQuestions = extractQuestionsFromNestedObject(obj[key], newPath);\n                            if (nestedQuestions.length > 0) {\n                                console.log(`âž• Adding ${nestedQuestions.length} questions from ${newPath}`);\n                                extractedQuestions = extractedQuestions.concat(nestedQuestions);\n                            }\n                        }\n                    }\n                }\n                \n                return extractedQuestions;\n            };\n            \n            try {\n                const coreModule = await import(`../../assessments/${assessmentType}/questions.json`);\n                const coreData = coreModule.default || coreModule;\n                \n                console.log(`ðŸ“ [${assessmentType}] Core questions data structure:`, Object.keys(coreData));\n                \n                // Handle different possible structures\n                if (Array.isArray(coreData)) {\n                    // Direct array structure\n                    coreQuestions = coreData;\n                    console.log(`ðŸ“Š Loaded ${coreQuestions.length} core questions (direct array)`);\n                } else if (coreData.coreQuestions) {\n                    // Structure with coreQuestions property\n                    if (Array.isArray(coreData.coreQuestions)) {\n                        // coreQuestions is a direct array\n                        coreQuestions = coreData.coreQuestions;\n                        console.log(`ðŸ“Š Loaded ${coreQuestions.length} core questions from coreQuestions array`);\n                    } else {\n                        // coreQuestions is an object with nested question arrays\n                        console.log(`ðŸ” Extracting questions from nested coreQuestions object with categories:`, Object.keys(coreData.coreQuestions));\n                        \n                        // First, let's log all the categories and their question counts\n                        for (const category in coreData.coreQuestions) {\n                            if (Array.isArray(coreData.coreQuestions[category])) {\n                                console.log(`ðŸ“Š Category ${category} has ${coreData.coreQuestions[category].length} direct questions`);\n                            } else if (typeof coreData.coreQuestions[category] === 'object') {\n                                console.log(`ðŸ” Category ${category} has nested structure:`, Object.keys(coreData.coreQuestions[category]));\n                            }\n                        }\n                        \n                        coreQuestions = extractQuestionsFromNestedObject(coreData.coreQuestions, 'coreQuestions');\n                        console.log(`ðŸ“Š Category question counts:`, categoryQuestionCounts);\n                        console.log(`ðŸ“Š Total extracted core questions: ${coreQuestions.length}`);\n                        \n                        // Verify by listing all question IDs\n                        const coreQuestionIds = coreQuestions.map(q => q.id);\n                        console.log(`ðŸ†” Core question IDs:`, coreQuestionIds);\n                    }\n                } else {\n                    // Try to extract questions from the entire object\n                    coreQuestions = extractQuestionsFromNestedObject(coreData);\n                    console.log(`ðŸ“Š Extracted ${coreQuestions.length} questions from entire data object`);\n                }\n                \n                if (coreQuestions.length === 0) {\n                    console.error(`âŒ Could not find questions array in core data structure:`, Object.keys(coreData));\n                }\n            } catch (error) {\n                console.error(`âŒ Error loading core questions for ${assessmentType}:`, error);\n            }\n            console.log(`ðŸ“Š Loaded ${coreQuestions.length} core questions`);\n            \n            // If we have selected services, load service-specific questions\n            let serviceQuestions = [];\n            \n            // Get selected services from context or responses\n            let selectedServices;\n            try {\n                selectedServices = getContext('selectedServices');\n                debugLog('Retrieved selectedServices from context', selectedServices);\n                \n                // If not in context, try to get from responses\n                if (!selectedServices || Object.keys(selectedServices).length === 0) {\n                    const servicesResponse = getResponse('selectedServices');\n                    if (servicesResponse) {\n                        selectedServices = servicesResponse;\n                        debugLog('Retrieved selectedServices from responses', selectedServices);\n                    }\n                }\n            } catch (err) {\n                console.error('Error getting selectedServices:', err);\n            }\n            \n            // Process service-specific questions if services are selected\n            if (selectedServices && Object.keys(selectedServices).length > 0) {\n                try {\n                    // Load service-specific questions - handle different file names based on assessment type\n                    let serviceData;\n                    \n                    try {\n                        // First try to load from service-questions.json (agency-vulnerability)\n                        debugLog(`Trying to load service questions from`, `../../assessments/${assessmentType}/service-questions.json`);\n                        const serviceModule = await import(`../../assessments/${assessmentType}/service-questions.json`);\n                        serviceData = serviceModule.default || serviceModule;\n                        debugLog('Loaded service questions from service-questions.json', Object.keys(serviceData));\n                    } catch (error) {\n                        // If that fails, try activity-questions.json (inhouse-marketing)\n                        debugLog(`First attempt failed, trying activity-questions.json`, error.message);\n                        try {\n                            debugLog(`Loading activity questions from`, `../../assessments/${assessmentType}/activity-questions.json`);\n                            const activityModule = await import(`../../assessments/${assessmentType}/activity-questions.json`);\n                            serviceData = activityModule.default || activityModule;\n                            debugLog('Loaded service questions from activity-questions.json', Object.keys(serviceData));\n                        } catch (activityError) {\n                            debugLog('Failed to load both service-questions.json and activity-questions.json', activityError.message);\n                            // Don't throw, just continue with empty service questions\n                            serviceData = null;\n                        }\n                    }\n                    \n                    // Extract service questions if service data was loaded\n                    if (serviceData) {\n                        debugLog('Service questions data structure', Object.keys(serviceData));\n                        \n                        // Determine the property containing service questions\n                        const serviceQuestionsData = serviceData.serviceQuestions || serviceData.activityQuestions || {};\n                        debugLog('Service/activity questions nested structure', Object.keys(serviceQuestionsData));\n                        \n                        // Define mappings from selected service IDs to question categories\n                        const serviceIdMappings = {\n                            // Agency mappings\n                            'content_creation': ['content_creation', 'content_marketing'],\n                            'creative_design': ['content_creation', 'creative_design'],\n                            'digital_marketing': ['content_creation', 'digital_marketing'], \n                            'seo_sem': ['content_creation', 'seo_sem'],\n                            'pr_comms': ['content_creation', 'strategy_consulting', 'pr_comms'],\n                            'web_development': ['strategy_consulting', 'web_development'],\n                            'social_media': ['content_creation', 'social_media'],\n                            \n                            // Inhouse mappings - direct matches to activity names\n                            'content_marketing': ['content_marketing'],\n                            'email_marketing': ['email_marketing'],\n                            'paid_advertising': ['paid_advertising'],\n                            'analytics_data': ['analytics_data'],\n                            'marketing_automation': ['marketing_automation']\n                        };\n                        \n                        // Process each selected service\n                        const ALLOCATION_THRESHOLD = 0.05; // 5% threshold\n                        \n                        Object.keys(selectedServices).forEach(serviceId => {\n                            const allocation = selectedServices[serviceId];\n                            \n                            if (allocation >= ALLOCATION_THRESHOLD) {\n                                debugLog(`Service ${serviceId} allocation ${allocation} exceeds threshold`, '');\n                                \n                                // Get the mapped question categories for this service ID\n                                const mappedCategories = serviceIdMappings[serviceId] || [serviceId];\n                                debugLog(`Service ${serviceId} maps to categories`, mappedCategories);\n                                \n                                // Process each mapped category\n                                let foundQuestionsForService = false;\n                                \n                                mappedCategories.forEach(mappedId => {\n                                    // Check if there's a direct match in serviceQuestionsData\n                                    if (serviceQuestionsData[mappedId]) {\n                                        const serviceObj = serviceQuestionsData[mappedId];\n                                        \n                                        // Handle both structures: nested 'questions' array or direct array\n                                        if (serviceObj.questions && Array.isArray(serviceObj.questions)) {\n                                            serviceQuestions = [...serviceQuestions, ...serviceObj.questions];\n                                            debugLog(`Found ${serviceObj.questions.length} questions for service ID ${mappedId}`, '');\n                                            foundQuestionsForService = true;\n                                        } else if (Array.isArray(serviceObj)) {\n                                            serviceQuestions = [...serviceQuestions, ...serviceObj];\n                                            debugLog(`Found ${serviceObj.length} questions for service ID ${mappedId}`, '');\n                                            foundQuestionsForService = true;\n                                        } else if (typeof serviceObj === 'object') {\n                                            // Try to extract questions from nested structure\n                                            const extractedQuestions = extractQuestionsFromNestedObject(serviceObj, mappedId);\n                                            if (extractedQuestions.length > 0) {\n                                                serviceQuestions = [...serviceQuestions, ...extractedQuestions];\n                                                debugLog(`Extracted ${extractedQuestions.length} questions from nested service object ${mappedId}`, '');\n                                                foundQuestionsForService = true;\n                                            }\n                                        }\n                                    } else {\n                                        // Try fuzzy matching by service name\n                                        Object.keys(serviceQuestionsData).forEach(key => {\n                                            if (key.toLowerCase().includes(mappedId.toLowerCase()) || \n                                                mappedId.toLowerCase().includes(key.toLowerCase())) {\n                                                \n                                                const serviceObj = serviceQuestionsData[key];\n                                                if (serviceObj.questions && Array.isArray(serviceObj.questions)) {\n                                                    serviceQuestions = [...serviceQuestions, ...serviceObj.questions];\n                                                    debugLog(`Found ${serviceObj.questions.length} questions for similar key ${key}`, '');\n                                                    foundQuestionsForService = true;\n                                                } else if (Array.isArray(serviceObj)) {\n                                                    serviceQuestions = [...serviceQuestions, ...serviceObj];\n                                                    debugLog(`Found ${serviceObj.length} questions for similar key ${key}`, '');\n                                                    foundQuestionsForService = true;\n                                                }\n                                            }\n                                        });\n                                    }\n                                });\n                                \n                                if (!foundQuestionsForService) {\n                                    debugLog(`Could not find any questions for service ${serviceId}`, '');\n                                }\n                            }\n                        });\n                    }\n                } catch (error) {\n                    console.error('Error loading service questions:', error);\n                }\n            } else {\n                console.warn('No services selected or invalid selectedServices format:', selectedServices);\n            }\n            \n            debugLog(`Found service-specific questions`, serviceQuestions.length);\n            \n            // Remove any potential duplicate questions by ID and validate questions\n            const uniqueQuestions = [];\n            const questionIds = new Set();\n            \n            // Process core questions first\n            coreQuestions.forEach(q => {\n                if (q && q.id && !questionIds.has(q.id)) {\n                    // Ensure question has all required properties\n                    if (!q.options || !Array.isArray(q.options) || q.options.length === 0) {\n                        debugLog(`Skipping invalid question without options:`, q.id);\n                        return;\n                    }\n                    \n                    questionIds.add(q.id);\n                    uniqueQuestions.push(q);\n                }\n            });\n            \n            // Then add service questions, avoiding duplicates\n            serviceQuestions.forEach(q => {\n                if (q && q.id && !questionIds.has(q.id)) {\n                    // Ensure question has all required properties\n                    if (!q.options || !Array.isArray(q.options) || q.options.length === 0) {\n                        debugLog(`Skipping invalid service question without options:`, q.id);\n                        return;\n                    }\n                    \n                    questionIds.add(q.id);\n                    uniqueQuestions.push(q);\n                }\n            });\n            \n            debugLog(`Total unique questions to display`, uniqueQuestions.length);\n            debugLog('Question IDs', Array.from(questionIds));\n            \n            setQuestions(uniqueQuestions);\n        } catch (error) {\n            console.error('Failed to load questions:', error);\n        } finally {\n            setLoading(false);\n        }\n    };\n\n    const currentQuestion = questions[currentQuestionIndex];\n    const isLastQuestion = currentQuestionIndex === questions.length - 1;\n\n    const handleAnswer = (questionId, value) => {\n        // Save the answer\n        saveResponse(questionId, value);\n        \n        // Log the answer being saved for debugging\n        debugLog(`Saving answer for question ${questionId}:`, value);\n        \n        // Try to retrieve all saved answers\n        if (typeof getResponse === 'function') {\n            const allAnswers = {};\n            questions.forEach(q => {\n                const answer = getResponse(q.id);\n                if (answer !== undefined) {\n                    allAnswers[q.id] = answer;\n                }\n            });\n            debugLog('Current saved answers:', allAnswers);\n        }\n        \n        // Auto-advance to next question after a short delay\n        setTimeout(() => {\n            if (currentQuestionIndex < questions.length - 1) {\n                setCurrentQuestionIndex(currentQuestionIndex + 1);\n            }\n        }, 300);\n    };\n\n    const handleNext = () => {\n        // Validate if the current question is answered\n        const currentQ = questions[currentQuestionIndex];\n        if (currentQ && currentQ.required !== false && !getResponse(currentQ.id)) {\n            alert('Please answer this question before continuing');\n            return;\n        }\n        \n        if (isLastQuestion) {\n            // Collect and log all answers for debugging\n            const allAnswers = {};\n            questions.forEach(q => {\n                const answer = getResponse(q.id);\n                if (answer !== undefined) {\n                    allAnswers[q.id] = answer;\n                }\n            });\n            debugLog('FINAL ANSWERS being submitted:', allAnswers);\n            debugLog('Number of answered questions:', Object.keys(allAnswers).length);\n            debugLog('Total questions:', questions.length);\n            \n            // Before completing, ensure selectedServices is stored in both context and responses\n            if (typeof getContext === 'function') {\n                const selectedServices = getContext('selectedServices');\n                if (selectedServices && typeof saveResponse === 'function') {\n                    // Save as a response to ensure it's available in both places\n                    saveResponse('selectedServices', selectedServices);\n                    debugLog('Saved selectedServices to responses as backup', selectedServices);\n                }\n            }\n            \n            // Set a global flag to indicate this component has completed with answers\n            if (typeof window !== 'undefined') {\n                window.dynamicQuestionsCompleted = true;\n                window.dynamicQuestionsAnswerCount = Object.keys(allAnswers).length;\n            }\n            \n            // Move to the next stage using onComplete callback\n            if (onComplete) {\n                onComplete();\n            }\n        } else {\n            setCurrentQuestionIndex(prev => prev + 1);\n        }\n    };\n\n    const handlePrevious = () => {\n        if (currentQuestionIndex > 0) {\n            setCurrentQuestionIndex(prev => prev - 1);\n        } else {\n            // Go back to the previous stage in the assessment flow\n            onBack();\n        }\n    };\n\n    const handleSkip = () => {\n        handleNext();\n    };\n\n    if (loading) {\n        return (\n            <div className={styles.loadingContainer}>\n                <div className={styles.spinner} />\n                <p>Loading questions...</p>\n            </div>\n        );\n    }\n\n    if (!currentQuestion) {\n        return (\n            <div className={styles.errorContainer}>\n                <p>No questions available for this assessment.</p>\n                <button onClick={onBack}>Go Back</button>\n            </div>\n        );\n    }\n\n    const selectedValue = getResponse(currentQuestion.id);\n\n    return (\n        <div className={styles.qualifyingContainer}>\n            <ProgressBar progress={progress || 65} stage=\"assessment\" />\n            \n            <div className={styles.questionContainer}>\n                <div className={styles.questionHeader}>\n                    <h2>Your Organization Assessment</h2>\n                    <p className={styles.questionNumber}>\n                        Question {currentQuestionIndex + 1} of {questions.length}\n                    </p>\n                </div>\n\n                {currentQuestion && (\n                    <div className={styles.questionContent}>\n                        <h3 className={styles.questionText}>\n                            {currentQuestion.question || currentQuestion.text}\n                            {currentQuestion.required !== false && <span className={styles.required}>*</span>}\n                        </h3>\n                        \n                        <div className={styles.optionsGrid}>\n                            {currentQuestion.options.map((option, index) => (\n                                <button\n                                    key={index}\n                                    className={`${styles.optionButton} ${\n                                        selectedValue === (option.value || option.score || index) ? styles.selected : ''\n                                    }`}\n                                    onClick={() => handleAnswer(currentQuestion.id, option.value || option.score || index)}\n                                >\n                                    <span className={styles.optionLabel}>{option.label || option.text}</span>\n                                </button>\n                            ))}\n                        </div>\n                        \n                        {currentQuestion.insight && (\n                            <p className={styles.questionInsight}>{currentQuestion.insight}</p>\n                        )}\n                        \n                        {currentQuestion.benchmark && (\n                            <p className={styles.questionBenchmark}>{currentQuestion.benchmark}</p>\n                        )}\n                    </div>\n                )}\n\n                {/* Question navigation dots */}\n                <div className={styles.questionDots}>\n                    {questions.map((_, index) => (\n                        <button\n                            key={index}\n                            className={`${styles.dot} ${\n                                index === currentQuestionIndex ? styles.active : ''\n                            } ${getResponse(questions[index].id) ? styles.answered : ''}`}\n                            onClick={() => setCurrentQuestionIndex(index)}\n                            aria-label={`Go to question ${index + 1}`}\n                        />\n                    ))}\n                </div>\n            </div>\n\n            <Navigation\n                onBack={handlePrevious}\n                onNext={handleNext}\n                onSkip={currentQuestion?.required === false ? handleSkip : null}\n                nextLabel={isLastQuestion ? \"Complete\" : \"Continue\"}\n                showNext={true}\n            />\n        </div>\n    );\n};\n\nexport default DynamicQuestions;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}