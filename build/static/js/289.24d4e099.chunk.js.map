{"version":3,"file":"static/js/289.24d4e099.chunk.js","mappings":"gLACO,MAAMA,EACTC,WAAAA,CAAYC,GACRC,KAAKD,OAASA,EACdC,KAAKC,OAAS,CACV,SACA,aACA,WACA,YACA,QACA,WAEJD,KAAKE,kBAAoB,CAC7B,CAEAC,KAAAA,GACIH,KAAKE,kBAAoB,CAC7B,CAEAE,eAAAA,GACI,OAAOJ,KAAKC,OAAOD,KAAKE,kBAC5B,CAEAG,OAAAA,GACI,OAAIL,KAAKM,mBACLN,KAAKE,oBACEF,KAAKK,YAGZL,KAAKE,kBAAoBF,KAAKC,OAAOM,OAAS,GAC9CP,KAAKE,oBAGFF,KAAKI,kBAChB,CAEAI,MAAAA,GACI,OAAIR,KAAKE,kBAAoB,IACzBF,KAAKE,oBAGDF,KAAKM,mBACEN,KAAKQ,SAGbR,KAAKI,iBAChB,CAEAK,QAAAA,CAASC,GACL,MAAMC,EAAQX,KAAKC,OAAOW,QAAQF,IACnB,IAAXC,IACAX,KAAKE,kBAAoBS,EAEjC,CAEAL,eAAAA,GAKI,QAAqB,WAJAN,KAAKI,oBAIOJ,KAAKD,OAAOc,WAKjD,CAEAC,oBAAAA,CAAqBC,GACjB,MAAMC,EAAmBD,EAAYE,WAAW,qBAAuB,GACjEC,EAAoBH,EAAYE,WAAW,eAAiB,CAAC,EAKnE,OAFqBjB,KAAKD,OAAOoB,WAAa,IAE1BC,QAAOC,IAEvB,GAAIA,EAASC,UAAYD,EAASC,SAASf,OAAS,EAAG,CAInD,IAH2Bc,EAASC,SAASC,MAAKC,GAC9CR,EAAiBS,SAASD,KAEL,OAAO,CACpC,CAGA,GAAIH,EAASK,WAAY,CAOrB,IANwBC,OAAOC,QAAQP,EAASK,YAAYG,OACxDC,IAA2B,IAAzBC,EAAKC,GAAcF,EACjB,MAAMG,EAAcf,EAAkBa,GACtC,OAAOC,EAAcP,SAASQ,MAGhB,OAAO,CACjC,CAEA,OAAO,IAEf,CAEAC,WAAAA,GACI,MAAMC,EAAcnC,KAAKC,OAAOM,OAC1B6B,EAAkBpC,KAAKE,kBAC7B,MAAO,CACHmC,QAASD,EAAkB,EAC3BE,MAAOH,EACPI,WAAYC,KAAKC,MAAOL,GAAmBD,EAAc,GAAM,KAC/DzB,UAAWV,KAAKI,kBAExB,CAEAsC,UAAAA,GACI,OAAO1C,KAAKE,oBAAsBF,KAAKC,OAAOM,OAAS,CAC3D,CAEAoC,KAAAA,GACI3C,KAAKE,kBAAoB,CAC7B,E","sources":["core/engine/FlowController.js"],"sourcesContent":["\nexport class FlowController {\n    constructor(config) {\n        this.config = config;\n        this.stages = [\n            'sector',\n            'qualifying',\n            'services',\n            'questions',\n            'email',\n            'results'\n        ];\n        this.currentStageIndex = 0;\n    }\n\n    start() {\n        this.currentStageIndex = 0;\n    }\n\n    getCurrentStage() {\n        return this.stages[this.currentStageIndex];\n    }\n\n    advance() {\n        if (this.shouldSkipStage()) {\n            this.currentStageIndex++;\n            return this.advance();\n        }\n\n        if (this.currentStageIndex < this.stages.length - 1) {\n            this.currentStageIndex++;\n        }\n\n        return this.getCurrentStage();\n    }\n\n    goBack() {\n        if (this.currentStageIndex > 0) {\n            this.currentStageIndex--;\n            \n            // Skip backwards through skipped stages\n            if (this.shouldSkipStage()) {\n                return this.goBack();\n            }\n        }\n        return this.getCurrentStage();\n    }\n\n    setStage(stageName) {\n        const index = this.stages.indexOf(stageName);\n        if (index !== -1) {\n            this.currentStageIndex = index;\n        }\n    }\n\n    shouldSkipStage() {\n        const currentStage = this.getCurrentStage();\n        \n        // Add skip logic based on assessment type and previous answers\n        // For example, skip sector selection if already specified in URL\n        if (currentStage === 'sector' && this.config.skipSector) {\n            return true;\n        }\n        \n        return false;\n    }\n\n    getRelevantQuestions(dataManager) {\n        const selectedServices = dataManager.getContext('selectedServices') || [];\n        const qualifyingAnswers = dataManager.getContext('qualifying') || {};\n        \n        // Filter questions based on selections\n        const allQuestions = this.config.questions || [];\n        \n        return allQuestions.filter(question => {\n            // Check service relevance\n            if (question.services && question.services.length > 0) {\n                const hasRelevantService = question.services.some(service => \n                    selectedServices.includes(service)\n                );\n                if (!hasRelevantService) return false;\n            }\n            \n            // Check qualifying conditions\n            if (question.conditions) {\n                const meetsConditions = Object.entries(question.conditions).every(\n                    ([key, allowedValues]) => {\n                        const actualValue = qualifyingAnswers[key];\n                        return allowedValues.includes(actualValue);\n                    }\n                );\n                if (!meetsConditions) return false;\n            }\n            \n            return true;\n        });\n    }\n\n    getProgress() {\n        const totalStages = this.stages.length;\n        const completedStages = this.currentStageIndex;\n        return {\n            current: completedStages + 1,\n            total: totalStages,\n            percentage: Math.round((completedStages / (totalStages - 1)) * 100),\n            stageName: this.getCurrentStage()\n        };\n    }\n\n    isComplete() {\n        return this.currentStageIndex === this.stages.length - 1;\n    }\n\n    reset() {\n        this.currentStageIndex = 0;\n    }\n}\n\nexport default FlowController;"],"names":["FlowController","constructor","config","this","stages","currentStageIndex","start","getCurrentStage","advance","shouldSkipStage","length","goBack","setStage","stageName","index","indexOf","skipSector","getRelevantQuestions","dataManager","selectedServices","getContext","qualifyingAnswers","questions","filter","question","services","some","service","includes","conditions","Object","entries","every","_ref","key","allowedValues","actualValue","getProgress","totalStages","completedStages","current","total","percentage","Math","round","isComplete","reset"],"sourceRoot":""}